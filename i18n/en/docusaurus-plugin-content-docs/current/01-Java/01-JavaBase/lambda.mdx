---
title: lambda usage
sidebar_label: lambda usage
sidebar_position: 1
---

## Java 8 function programming

> NOTES: Featured to Java 8 function programming

### Rebuild Legacy Code

```java
public Set<String> findLongTracks(List<Album> albums) {
    Set<String> trackNames=new HashSet<>();
    for(Album album : albums) {
        for (Track track : album.getTrackList()) {
            if (track.getLength() > 60) {
                String name=track.getName();
                trackNames.add(name);
            }
        }
    }
    return trackNames;
}
```

Reload 1 `for` to `forEach`

```java
public Set<String> findLongTracks(List<Album> albums) {
    Set<String> trackNames=new HashSet<>();
    albums.stream()
        .forEach(album-> {
            album.getTracks()
                .forEach(track-> {
                    if (track.getLength() > 60) {
                        String name=track.getName();
                        trackNames.add(name);
                    }
                });
        });
    return trackNames;
}
```

Rebuild 2 `if` to `filter`

```java
public Set<String> findLongTracks(List<Album> albums) {
    Set<String> trackNames=new HashSet<>();
    albums.stream()
        .forEach(album-> {
            album.getTracks()
                .filter(track-> track.getLength() > 60)
                .map(track-> track.getName())
                .forEach(name-> trackNames.add(name));
        });
    return trackNames;
}
```

Restructuring 3 outer `forEach` into `faltMap`

```java
public Set<String> findLongTracks(List<Album> albums) {
    Set<String> trackNames=new HashSet<>();
    albums.stream()
        .flatMap(album-> album.getTracks())
        .filter(track-> track.getLength() > 60)
        .map(track-> track.getName())
        .forEach(name-> trackNames.add(name));
    return trackNames;
}
```

Rebuild 4 `forEach` to add elements to `collect`

```java
public Set<String> findLongTracks(List<Album> albums) {
    return albums.stream()
        .flatMap(album-> album.getTracks())
        .filter(track-> track.getLength() > 60)
        .map(track-> track.getName())
        .collect(toSet());
}
```

### Function Method Parameters Reload

```java
overloadedMethod((x, y)-> x+y);

private interface IntegerBiFunction extends BinaryOperator<Integer> {
}
private void overloadedMethod(BinaryOperator<Integer> Lambda) {
    System.out.print("BinaryOperator");
}
private void overloadedMethod(IntegerBiFunction Lambda) {
    System.out.print("IntegerBinaryOperator");
}
```

> Accepts `BinaryOperator` and a subclass of the interface as parameters, respectively.When called these methods, the type of Lambda expression that JavaScript exported, is the type of the most specific function interface.For example, `IntegerBinaryOperator`, when selected in two approaches to Example 4-8, is output.

General principles

-   If there is only one possible target type, derived by the parameter type in the corresponding function interface;

-   If there are more than one possible target type, it is derived by the most specific type;

-   If there are more than one possible target type and the most specific type is unclear, the specified type needs to be artificial.

### Interface Inherit

```java
public interface Jukebox {
    public default String rock() {
        return "... all over the world! ";
    }
}

public interface Carriage {
    public default String rock() {
        return "... from side to side";
    }
}

public class MusicalCarriage implements Carriage, Jukebox {
}
```

`javac` does not specify which method should inherit in an interface, so the compiler will reportï¼šclass Medical Carriage inside herits related default results for rock() from types Carriage and Jukebox.

```java
public class MusicalCarriage
    implements Carriage, Jukebox {
    @Override
    public String rock() {
        return Carriage.super.rock();
    }
}
```

General principles

-   Class is better than interface.The methods defined in the interface can be overlooked if there is a declaratory or abstract method in the chain of inheritance.

-   Subclass is better than ParentIf an interface inherits another interface, and both interfaces define a default method, the method defined in the subclass was.

-   There is no rule III.If the above two rules do not apply, the subcategory either needs to implement the method or declare it to be an abstract one.

5.  For example, when using parallel currents, the `forEach` method does not guarantee that elements are treated sequentially.If there is a need to ensure sequencing, the `forEachOrdered` method should be used.

### Subcollector `groupingBy`

```java
public Map<Artist, List<String>> nameOfAlbums(Stream<Album> albums) {
    return albums.collect(groupingBy(Album::getMainMusician, mapping(Album::getName, toList())));
}
```

mapping allows similar map actions on collector containers.However, it is necessary to specify what collection class to use, such as `toList`.

### Restructuring Realm Method

```java
public long countFeature(ToLongFunction<Album> function) {
    return albums.stream()
        .mapToLong(function)
        .sum();
}
public long countTracks() {
    return countFeature(album-> album.getTracks().count());
}
public long countRunningTime() {
    return countFeature(album-> album.getTracks()
                        .mapToLong(track-> track.getLength())
                        .sum());
}
public long countMusicians() {
    return countFeature(album-> album.getMusicians().count());
}
```

### Tips

-   Whether an operation is inert or early is simple: to see only its return value.If the return value is Stream, it is an inert value; if the return value is another value or empty, it is an early value.

-   By extracting the lambda logic into a single method, the method can be tested to cover all boundary cases

-   Use peek method to observe lambda intermediate value

```java
Set<String> nationalities = album.getMusicians()
    .filter(artist-> artist.getName().startsWith("The"))
    .map(artist-> artist.getNationality())
    .peek(nation-> System.out.println("Found nationality: "+nation))
    .collect(Collectors.<String>toSet());
```
