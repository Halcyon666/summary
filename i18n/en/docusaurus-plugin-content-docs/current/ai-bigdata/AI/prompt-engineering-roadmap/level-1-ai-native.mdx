---
id: level-1-ai-native
title: Level 1 - AI-Native Workflow & Infrastructure
sidebar_label: Level 1 - AI-Native Workflow
sidebar_position: 2
description: Establish AI-first development habits and build local AI infrastructure
tags:
- ai
- prompt-engineering
- level-1
sources:
- overview
references:
- level-2-rag
- mcp
- prompt
- wsl-opencode
- oh-my-opencode
- vibe-coding
last_update:
  date: '2026-01-25'
  author: halcyon666
---

# Phase 1: AI-Native Workflow & Infrastructure (Level 1)

**Cycle**: Weeks 1-2
**Core Goal**: Establish AI-first development habits and build local AI infrastructure

## Prerequisite Capabilities

- Master at least one programming language (Python/Java/JavaScript)
- Understand basic command line operations and Docker usage

## Why this phase is needed

AI tools are not just "code completion", but about **refactoring the entire development lifecycle**. Must establish AI-Native working habits first to efficiently learn complex AI technologies in subsequent phases.

## ⭐ Core Capability 1: IDE Mastery & Prompt Engineering Basics

### ⭐ Goal

Force yourself **not to write** Boilerplate Code, drive code generation through Prompt.

### Practice Standards

**Quantitative Goals** (Verifiable Success Criteria):
- **Project Level**: In a project containing 10 files, at least 8 files (80%) of initial versions are generated by AI.
- **File Level**: Boilerplate code (imports, class definitions, basic CRUD methods) in each file is 100% generated by AI.
- ⭐ **Iteration Efficiency**: Average iteratons per file to reach usable state is ≤ 3 prompts.

**Workflow** (Mandatory Three Steps):
- **Generate**: Use Cursor/Windsurf's `Cmd+K` or `Composer` to generate code via natural language description.
- ⭐ **Verify**: If generated code does not meet requirements, **manual modification is prohibited**, instead analyze problem and modify Prompt.
- ⭐ **Precipitate**: Save effective Prompt templates to personal `.cursorrules` file, including project code standards and best practices.

### ⭐ Prompt Template Examples

<details>
<summary>Template 1: DDD Architecture Code Generation</summary>
```markdown
# Role: DDD Java Aggregate Root Code Generation Expert

## Profile
- author: LangGPT
- version: 1.0
- language: English
- description: 
You are a senior Java architect proficient in Domain-Driven Design (DDD), skilled in modeling business rules into high-cohesion, strong-constraint Aggregate Root entities, and outputting code ready for production.

## Skills
- Deep understanding of Aggregate Roots, Entities, Value Objects, Domain Events in DDD
- Proficient in using Java 17 for domain modeling
- Able to transform business rules into internal invariant constraints of entities
- Use Lombok and modern Java syntax to write concise, maintainable code

## Background
Need to model an Aggregate Root entity for a specific domain context based on Domain-Driven Design.
The entity must reflect business rules and behaviors, rather than being a simple data carrier (avoid Anemic Domain Model).

## Goals
- Generate an Aggregate Root entity class conforming to DDD principles
- Entity needs to encompass business logic and maintain its own invariants through methods
- Clear code structure, usable as core model of domain layer

## Rules
1. Use **Java 17** syntax
2. Aggregate root must be a **Rich Domain Model**, containing necessary business methods
3. Must explicitly model:
   - Entity ID (as Value Object or Strong Type)
   - At least one Value Object
   - At least one Domain Event (Only definition, no infrastructure involved)
4. Use **Lombok** (e.g. `@Getter`, `@EqualsAndHashCode` etc.) to reduce boilerplate code
5. Write **detailed Javadoc** for class, core attributes, and key methods
6. Do not introduce persistence framework annotations (e.g. JPA)
7. Output content **only contains complete Java code**

## Workflows
1. Analyze domain context and business rules
2. Identify aggregate root boundaries and core invariants
3. Design entity, value objects and domain events
4. Output complete, readable entity class code conforming to DDD

## Input
- Domain Context:
  - Entity Name: User
  - Core Attributes:
    - userId (Unique Identifier)
    - email (Must be unique)
    - profile (Optional Value Object)
  - Business Rules:
    - email must be unique in system (Guaranteed by domain layer semantics)
    - profile can be null, but once exists must be complete and valid

## OutputFormat
- Single Java file
- Contains:
  - Aggregate Root Entity `User`
  - Necessary Value Objects
  - At least one Domain Event class

## Init
Please generate **complete User Aggregate Root entity class code** based on above constraints.
```
</details>

**Counter Example**:
```
❌ "Help me write a User class"
   → Too vague, no description of architecture style, tech stack, business rules
```


<details>
<summary>⭐ Template 2: Error Debugging</summary>
```markdown
You are an experienced Python debugging expert, proficient in FastAPI and Milvus related development.

## Project and Environment Information
- Project Type: FastAPI + Milvus RAG System
- Python Version: 3.11
- Runtime Environment: Docker
- Error Trigger Timing: When inserting vectors into Milvus

## Error Log
Please paste complete Stack Trace below:
---
[Paste complete Stack Trace]
---

## Related Code
Please provide error code snippet (Suggest 10 lines before and after):
---
[Paste code snippet]
---

## Analysis Requirement
Please conduct detailed analysis based on above information, including:

1. **Root Cause**: Please explicitly point out core cause of error.
2. **Reason for Error**: Explain why this error occurs, including possible environment, dependency or logic issues.
3. **Solutions**: Provide 3 feasible solutions, and sort by recommendation priority, explaining pros and cons of each solution.
4. **Prevention Advice**: Give best practices or protective measures for similar problems.

```
</details>

**Counter Example**:
```
❌ "How to solve this error: [Only paste one line error message]"
   → Missing context, AI cannot analyze accurately
```

### Quality Verification Standards

**Capability Verification Checklist** (Must achieve all):
- [ ] **Code Generation Capability**: Able to generate over 80% boilerplate code via natural language description, without manual supplementation
- [ ] ⭐ **Prompt Library Construction**: Establish personal Prompt Library, containing at least 5 templates (1 each for code gen, debug, refactor, test, doc)
- [ ] ⭐ **Iteration Optimization Capability**: Able to correct AI generated code through iterating Prompt (instead of manual modification), average iteration count ≤ 3
- [ ] **Debug Accuracy**: In 10 error debugging sessions, AI gives correct Root Cause in top 3 suggestions ≥ 7 times (70% accuracy)

**Verification Method**: Choose a small project (e.g. Todo List API), generate all code using AI from scratch, record generation ratio and iteration count.

## ⭐ Core Capability 2: Infrastructure Setup

### ⭐ Local Model Deployment

**Ollama Deploy Llama 3.1 / Qwen 2.5 (8B)**

**Quantization Technology Understanding** (Must master core concepts):
- **Q4_0 (4-bit Quantization)**: Each parameter uses 4 bits, 8B model approx 4.5GB, suitable for 8GB VRAM consumer cards
- **FP16 (16-bit Half Precision)**: Each parameter uses 16 bits, 8B model approx 16GB, requires professional cards
- **Trade-off**: Q4_0 loses about 1-2% precision, but VRAM usage reduced by 75%, suitable for local development

**VRAM Usage Calculation Formula**:
```
Total VRAM = (Model Params × Quantization Bits / 8) + Context Cache
Example: 8B Model Q4_0 = (8 × 10^9 × 4 / 8) / 10^9 ≈ 4GB + 0.5GB (Context) = 4.5GB
```

**Practical Verification**: Run `ollama run qwen2.5:8b` and use `nvidia-smi` or `Activity Monitor` to verify VRAM usage

### Connection Protocol: MCP (Model Context Protocol)

**Practical Task**: Write a Python MCP Client to let Ollama call local `add_numbers` tool

```python
# Example: MCP Client Basic Structure
from mcp import Client

client = Client()
client.register_tool("add_numbers", lambda a, b: a + b)
response = client.query("What is 123 + 456?")
print(response)  # Should call add_numbers tool
```

### ⭐ Containerized Environment

Use Docker Compose to deploy local services:
- ⭐ Milvus (Vector Database)
- Dify (Low-code AI Platform)
- Neo4j (Knowledge Graph, Optional)

## Core Capability 3: Python Data Stack Basics

**Why need Python**: AI ecosystem is mainly based on Python, even if you are a Java developer, you need to master Python to handle AI inference logic.

**Learning Focus**:
- **Pandas/NumPy**: Master vectorized calculation (Basis for Embedding)
- **PyTorch Basics**:
  - Tensor dimension operation `[Batch, Seq, Dim]`
  - `.to('cuda')` device management
  - Load pre-trained model (No need training from scratch)

:::tip Tool Relationship Understanding
- **NumPy**: Handle number matrix on CPU
- **PyTorch**: Handle number matrix on GPU, and adds "Automatic Differentiation" (Core of Neural Network learning)
- **Model (LLM/BERT)**: Essentially a super complex mathematical formula written in PyTorch
:::

## Phase Output Standards

**Deliverables Must Complete** (As prerequisites for entering Level 2):

**Infrastructure Layer**:
- [X] ⭐ Successfully deploy local Ollama and run 8B model, able to get response via API call
- [X] Complete at least 1 MCP Client example, implement Ollama calling local tool function
- [ ] ⭐ Successfully deploy at least 2 AI related services (Milvus + Dify or Neo4j) using Docker Compose

**Prompt Engineering Layer**:
- [ ] ⭐ Establish personal Prompt Library, containing at least 5 templates, covering: code gen, debug, refactor, test, doc
- [ ] ⭐ Complete configuration of Cursor/Windsurf (including `.cursorrules` file), and practice AI generating 80% code in a small project

**Capability Verification**:
- [ ] Able to independently complete setup of a small project (e.g. RESTful API), 80% code generated by AI
- [ ] ⭐ Able to solve at least 3 actual coding problems through Prompt iteration, without manually modifying code

**Time Checkpoint**: If not completed after 2 weeks, need to re-evaluate learning method or reduce project complexity

---

**Next Phase**: [Level 2 - RAG App Development & Heterogeneous System Architecture](./level-2-rag)
