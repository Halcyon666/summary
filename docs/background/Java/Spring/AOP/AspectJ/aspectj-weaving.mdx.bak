---
title: AspectJ织入方法
sidebar_label: 织入方法
---

本文相关代码(来自[官方源码](https://github.com/spring-projects/spring-framework.git "官方源码")spring-test模块)请参见[spring-framework](https://github.com/Halcyon666/spring-framework-modified/tree/main/spring-test) org.springframework.mylearntest包下。

## 两种织入Aspect方法

假如我们有一个目标对象Foo，有两种方式将Aspect定义织入这个目标对象类，实现对其符合Pointcut定义的Joinpoint进行拦截。

<details>
	<summary>Foo</summary>

```java
public class Foo {
	public void method1() {
		System.out.println("method1 executed");
	}

	public void method2() {
		System.out.println("method2 executed");
	}
}
```
</details>


### 编程方式织入

<details>
	<summary>通过AspectJProxyFactory实现</summary>

```java
public class Test4AspectJProxyFactory {
	public static void main(String[] args) {
		AspectJProxyFactory weaver = new AspectJProxyFactory();
		weaver.setProxyTargetClass(true);
		weaver.setTarget(new Foo());
		weaver.addAspect(PerformanceTraceAspect.class);
		Object proxy = weaver.getProxy();
		((Foo)proxy).method1();
		((Foo)proxy).method2();
	}
}
```
</details>

### 通过自动代理织入

针对@AspectJ风格的AOP，Spring AOP专门提供了一个AutoProxyCreator实现类进行自动代理，以免去过多的编码和配置工作，它是在AbstractAdvisorAutoProxyCreator基础上的一个扩展类。

与AutoProxyCreator一样，我们需要在IoC容器的配置文件中注册一下AnnotationAwareAspectJAutoProxyCreator就可以了。

![](https://s2.loli.net/2023/07/15/hrGdFWtgxbfa78l.png)


<details>
	<summary>xml 配置</summary>

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	   xmlns:aop="http://www.springframework.org/schema/aop"
	   xsi:schemaLocation="http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans-2.5.xsd

		 http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd">

	<aop:aspectj-autoproxy proxy-target-class="true"/>
	<!--	等同于上面一行-->
	<!--<bean class="org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator">
		<property name="proxyTargetClass" value="true"/>
	</bean>-->

	<bean id="performanceAspect" class="org.springframework.mylearntest.aop2.aspectj.PerformanceTraceAspect"/>

	<bean id="target" class="org.springframework.mylearntest.aop2.aspectj.Foo"/>
</beans>
```
</details>

<details>
	<summary>TestAutoAspectJ</summary>

```java
public class Test4AutoAspectJ {
	public static void main(String[] args) {
		ApplicationContext context = new ClassPathXmlApplicationContext("annotationawareaspectJautoproxycreator\\annotationawareaspectJautoproxycreator.xml");
		Object proxy = context.getBean("target");
		((Foo)proxy).method1();
		((Foo)proxy).method2();
	}
}
```
</details>

如果把target作为依赖对象注入其他的bean定义，那么依赖的主体对象在持有的也是被代理过的目标对象。

**Tip**
> 在使用@AspectJ形式的AOP的时候，应该尽量使用容器内的自动代理支持，通常，只有处于测试目的才会使用编程的方式直接织入操作，在使用过程中，你会发现，实际上这两种方式是有差异的，一些行为并不统一。
> 
> 使用@Aspect形式的AOP，需要引入aspectjweaver.jar和aspectjrt.jar。


import TailProtocal from "@site/src/components/TailProtocal";

<TailProtocal />
