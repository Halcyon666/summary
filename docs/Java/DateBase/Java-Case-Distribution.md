---
title: "分布式问题"
hidemeta: true
---

## 分布式事务解决方案？

1. 基于`XA`协议的：二阶段提交和三阶段提交
2. 基于时间补偿机制：TCC 基于业务层面实现
3. 本地消息表：基于数据库+mq，通过mq调用服务，完成响应后回调，将状态盖好才能完成。需要配合定时任务扫描，重发消息调用服务，需要保证幂等性；(不推荐使用)
4. 基于事务消息：MQ

> https://www.cnblogs.com/duanxz/p/4672708.html 
>
> https://www.freesion.com/article/29161397034/
>
> 针对 `XA` 相关文章阅读总结
>
> **二阶段提交**：
>
> 1. 二阶段提交分别是 **Prepare**(*尽可能的多干活，这样commit 的时候就更快*)、**Commit**，或者 **Prepare、Rollback**
> 2. 当资源不足，或者超时时容器出现经验异常(Heuristic Exception)；
> 3. 当使用数据`XA`驱动时(非必要不要使用)，不要使用`DDL`(Data Define Language)语句操作、不要使用嵌套事务
> 4. 二阶段提交存在同步阻塞、单点故障、数据不一致、二阶段状态不明问题
> 5. `XA` `mysql`需要`Innodb`引擎是支持
>
> **三阶段提交**

> 1. 相比二阶段提交，引入了超时机制。保证最后提交阶段之前各参与者节点的状态是一致的
> 2. 三阶段提交分别是：`CanCommit`，`PreCommit`（*prepare执行`Sql`*）、`DoCommit`
>
> Q: 三阶段提交过程中，`DoCommit `时，协调者收到一个失败，然后【参与者回滚失败】或者【参与者回滚成功响应协调者超时】，该如何？
>
> *思考：是再次发送回滚请求，还是直接终止事务；如果再次发送请求如果一直失败怎么办？如果直接终止事务，有参与者回滚失败会导致数据不一致的问题；*
>
> **`XA` 和 `JTA`区别**
>
> `XA`：处理分布式事务的规范
>
> `JTA`：JAVA处理分布式事务的规范

> MQ实现分布式事务？
>
> https://www.cnblogs.com/wudimanong/p/10558710.html
>
> ![img](https://img2018.cnblogs.com/blog/1571688/201903/1571688-20190319145006150-240188785.png)




## 实现分布式锁

利用唯一约束，插入表成功获取锁成功，插入表失败获取锁失败；如果操作执行完需要删除锁。

该锁不可重入，如果要实现可以维护当前获取锁线程的唯一标识，再重入时判断是否为当前获取锁的线程，是则默认获取锁成功。
