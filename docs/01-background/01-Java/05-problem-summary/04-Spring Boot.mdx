# Spring Boot

## Singleton Inject but need dynamic changing value

A bug finds in those of tasks where you need change the date by the nature. <br/>
Firstly You should inject a prototype bean to spring context, instead of injecting a singleton object; Secondly you need use this way.

```java
@Component
public class SingletonService {

    // ä½¿ç”¨ ObjectFactoryï¼ˆä¹Ÿå¯ä»¥ç”¨ javax.inject.Provider æˆ– Spring çš„ Providerï¼‰
    @Resource
    // highlight-next-line
    private ObjectFactory<PrototypeBean> prototypeBeanFactory;

    public void callTest() {
        PrototypeBean prototypeBean = prototypeBeanFactory.getObject();
        prototypeBean.doSomething();
    }
}
```

## å¯åŠ¨é—®é¢˜

### Springbootå¯åŠ¨æ—¶æŠ¥é”™ org.springframework.bootä¸å­˜åœ¨

***å»ºè®®é‡‡ç”¨æ–¹æ³•äºŒåœ¨ç»ˆç«¯ä¸­è¾“å…¥`mvn idea:idea`ï¼Œæ–¹æ³•ä¸€åœ¨Spring Boot é¡¹ç›®ä¸­ï¼Œè¿è¡Œå…¶ä»–Mainæ–¹æ³•æµ‹è¯•ç±»çš„æ—¶å€™ä¼šé‡æ–°å¯åŠ¨SpringBoot å·¥ç¨‹ï¼Œå¦‚æœä½ è¿˜ä»ApplicationContextä¸­è·å–ï¼Œé‚£ä¹ˆå°†ä¼šæ”¶åˆ°æŠ¥é”™å®¹å™¨å·²ç»å…³é—­ã€‚***
[å‚è§åšå®¢](https://blog.csdn.net/qq_35456400/article/details/107190640)

### spring bootæºç è¿è¡ŒSpringApplicationæ—¶æŠ¥é”™

Could not find artifact lifecycle-mapping:lifecycle-mapping:jar:sources:1.0.0
[å‚è§åšå®¢ å·²ç»è¦ä»˜è´¹çœ‹äº†ï¼æ— è¯­](https://blog.csdn.net/awecoder/article/details/101159870)

### gradle spring boot 3.0 å¯¼å…¥æŠ¥é”™

[æ— æ•ˆçš„æºå‘è¡Œç‰ˆ: 17](https://stackoverflow.com/questions/69696321/intellij-invalid-source-release-17)

ç¡®ä¿gradleçš„ç‰ˆæœ¬JDK 17 å’Œ JDK çš„ç‰ˆæœ¬æ­£ç¡®ã€‚

![image-20230728021351697](https://s2.loli.net/2023/07/28/UzsD4BnrPYSbo1T.png)

## æ—¥å¿—ç›¸å…³

### å¯åŠ¨æ§åˆ¶å°æ—¥å¿—æ²¡æœ‰é¢œè‰²

åœ¨spring-logback.xmlä¸­å¼•å…¥
```xml
<include resource="org/springframework/boot/logging/logback/base.xml"/>
<logger name="org.springframework.web" level="INFO"/>
<logger name="org.springboot.sample" level="TRACE"/>
```

### logback ä¿®æ”¹æ—¥å¿—æ‰“å°å†…å®¹

ä»£ç : extends ThrowableHandlingConverter
impl convert æ–¹æ³•

logbacké…ç½®
```xml
<conversionRule convertionWord="someKeyMsg" convertClass="com.xxx.xxx.Xclass"/>
```


## æ‰“åŒ…é—®é¢˜

### after run the packaged jar occurs this unable to find main class

æ–¹æ³•1. æ›¿æ¢æ’ä»¶
```xml
<!--<plugin>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-maven-plugin</artifactId>
	<configuration>
		<mainClass>none</mainClass>
		<classifier>execute</classifier>
	</configuration>
	<executions>
		<execution>
			<goals>
				<goal>repackage</goal>
			</goals>
		</execution>
	</executions>
</plugin>-->
<plugin>
	<groupId>org.apache.maven.plugins</groupId>
	<artifactId>maven-source-plugin</artifactId>
	<version>3.0.1</version>
	<executions>
		<execution>
			<id>attach-sources</id>
			<goals>
				<goal>jar</goal>
			</goals>
		</execution>
	</executions>
</plugin>
```

æ–¹æ³•2: å»æ‰spring-boot parentï¼Œå†ä½¿ç”¨spring boot plugin æ‰“åŒ…

---

## å•å…ƒæµ‹è¯•é—®é¢˜

### `@DirtiesContext`

åŒä¸€ä¸ªç±»ä¸­å•å…ƒæµ‹è¯•æ–¹æ³•ä¹‹é—´ç›¸å…³å½±å“ï¼Œveryè°ƒç”¨æ¬¡æ•°æœ¬æ¥æ˜¯ä¸€æ¬¡ï¼Œå‰é¢çš„ä¸€ä¸ªæµ‹è¯•æ–¹æ³•ä¼šå½±å“åé¢çš„æ–¹æ³•ï¼Œéœ€è¦åœ¨å•å…ƒæµ‹è¯•ç±»ä¸Šé¢åŠ è¿™ä¸ªã€‚

```java
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METH
```

### Assert log content

1. [System out é‡å®šå‘](https://github.com/Halcyon666/learn-cases/blob/2e543cf044a8e67a0ae1cbde5fe3ab8aa5b1637e/learncases/src/test/java/com/whalefall/override/TestClassTest.java#L48)

2. LogCaptor (Recommendation)

```java title="MyServiceTest "
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.boot.test.system.CapturedOutput;
import org.springframework.boot.test.system.OutputCaptureExtension;

import static org.assertj.core.api.Assertions.assertThat;
// highlight-next-line
@ExtendWith(OutputCaptureExtension.class)
// If CapturedOutput is used by several methods, just opening next line comment
// @SpringBootTest
class MyServiceTest {
    
    @Test
    void shouldLogMessage(CapturedOutput output) {
		// highlight-next-line
        MyService service = new MyService();
        service.doSomething();
        assertThat(output.getOut()).contains("Expected log message");
    }
}
```

### Mock annotation

1. using spring boot test

getting the real annotation from classes

2. using a tempt inner class

```java
@UseTemplate(DemoTemplate.class)
static class DemoBusiness implements Business<String> {
    @Override
    public void process(String input) {
        // no-op
    }
}

static class DemoTemplate implements Template<String, DemoBusiness> {
    @Override
    public void handler(String txcode, String param, DemoBusiness businessService) {
        // mock behavior
    }
}
@Test
void testInit_withUseTemplateAnnotation() {
    ApplicationContext ctx = mock(ApplicationContext.class);
    DemoTemplate demoTemplate = new DemoTemplate();
    when(ctx.getBean(DemoTemplate.class)).thenReturn(demoTemplate);

    Map<String, DemoBusiness> map = Map.of("job1", new DemoBusiness());

    RegisterEnginV3<String, DemoBusiness> engin =
        new RegisterEnginV3<>(map, Map.of(), new HashMap<>(), ctx);

    engin.init(); // âœ… Will read @UseTemplate(DemoTemplate.class)
}
```

3. new a annotion instance to use.

## åŒä¸€ä¸ªç±»ä¸­å•å…ƒæµ‹è¯•æ–¹æ³•ä¹‹é—´ç›¸å…³å½±å“

veryè°ƒç”¨æ¬¡æ•°æœ¬æ¥æ˜¯ä¸€æ¬¡ï¼Œå‰é¢çš„ä¸€ä¸ªæµ‹è¯•æ–¹æ³•ä¼šå½±å“åé¢çš„æ–¹æ³•ï¼Œéœ€è¦åœ¨å•å…ƒæµ‹è¯•ç±»ä¸Šé¢åŠ è¿™ä¸ªã€‚

```java
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METH
```

## Depends on @PostConstruct

You can create it, pass parameter by new construction, then call the init method .

```java
@Service
@AllArgsConstructor
public class RegisterEnginV3<T, S extends Business<T>> {

    @PostConstruct
    public void init() {
        businessesMap.forEach((txcode, businessService) -> {
            // 1. è§£æ @UseTemplate æ³¨è§£
            UseTemplate ann = businessService.getClass()
                .getAnnotation(UseTemplate.class);

            // 2. è·å–å¯¹åº”çš„ Template Bean
            Template<T, S> templateToUse =
                (Template<T, S>) applicationContext
                    .getBean(ann.value());

            // 3. æ³›å‹ç±»å‹æ£€æŸ¥
            checkConsistentGenericType(businessService, templateToUse);

            // 4. æ³¨å†Œåˆ°æ‰§è¡Œæ³¨å†Œè¡¨
            registry.put(txcode,
                param -> templateToUse.handler(txcode, param, businessService));
        });
    }

    public void run(String businessType, T params) {
        registry.get(businessType).accept(params);
    }
}
```

## @MockBean å¤±æ•ˆé—®é¢˜

debugå‘ç°ä¸€ä¸ª@Resourceå¯¹è±¡é‡Œé¢çš„å±æ€§å·²ç»åœ¨å•å…ƒæµ‹è¯•ä¸­å†™äº†@MockBean ä½†æ˜¯ä¾ç„¶æ³¨å…¥äº†çœŸå®çš„å¯¹è±¡

**âœ… æ–¹æ¡ˆ 1ï¼šæ”¹ç”¨**

**@Autowired**

æœ€ç›´æ¥ã€å®˜æ–¹æ¨èçš„æ–¹å¼ã€‚

@MockBean ä¸“é—¨ä¸º @Autowired æœºåˆ¶è®¾è®¡ã€‚

## Mockçš„æ–¹æ³• æ”¹å˜å‚æ•°çš„å±æ€§

éå¸¸å¥½çš„é—®é¢˜ ğŸ‘

ä½ è¿™ä¸ªåœºæ™¯éå¸¸å…¸å‹ï¼š

âœ… é—®é¢˜åœºæ™¯

ä¸€ä¸ªè¢« @MockBean çš„å¯¹è±¡ï¼ˆæ¯”å¦‚ service æˆ– clientï¼‰ï¼Œ

å®ƒæœ‰ä¸€ä¸ª void æ–¹æ³•ï¼Œåœ¨æ–¹æ³•é‡Œä¼šä¿®æ”¹ä½ ä¼ å…¥çš„å¯¹è±¡ï¼ˆä¾‹å¦‚è®¾ç½®å­—æ®µï¼‰ã€‚

åœ¨å•å…ƒæµ‹è¯•ä¸­ï¼Œä½ æƒ³æ¨¡æ‹Ÿè¿™ä¸ªè¡Œä¸ºï¼Œè®©è¯¥å¯¹è±¡çš„å±æ€§è¢«è®¾ç½®ã€‚

```java
@Service
public class OrderService {
    @Autowired
    private PaymentClient paymentClient;

    public void process(OrderContext ctx) {
        paymentClient.fillPaymentInfo(ctx);  // void æ–¹æ³•ï¼Œå†…éƒ¨ä¼šè®¾ç½® ctx çš„å­—æ®µ
    }
}

public class PaymentClient {
    public void fillPaymentInfo(OrderContext ctx) {
        ctx.setPayStatus("SUCCESS");
        ctx.setPayAmount(100);
    }
}
```

doAnswer() å¯ä»¥è®©ä½ å®šä¹‰åœ¨è°ƒç”¨ void æ–¹æ³•æ—¶çš„è‡ªå®šä¹‰è¡Œä¸ºã€‚

```java
@SpringBootTest
class OrderServiceTest {

    @Autowired
    private OrderService orderService;

    @MockBean
    private PaymentClient paymentClient;

    @Test
    void testProcess() {
        // 1ï¸âƒ£ æ¨¡æ‹Ÿ PaymentClient å¯¹ fillPaymentInfo çš„è¡Œä¸º
        doAnswer(invocation -> {
            OrderContext ctx = invocation.getArgument(0);
            ctx.setPayStatus("MOCK_SUCCESS");
            ctx.setPayAmount(999);
            return null; // å› ä¸ºç›®æ ‡æ–¹æ³•æ˜¯ void
        }).when(paymentClient).fillPaymentInfo(any(OrderContext.class));

        // 2ï¸âƒ£ è°ƒç”¨å®é™…ä¸šåŠ¡
        OrderContext context = new OrderContext();
        orderService.process(context);

        // 3ï¸âƒ£ æ–­è¨€æ¨¡æ‹Ÿæ•ˆæœ
        assertEquals("MOCK_SUCCESS", context.getPayStatus());
        assertEquals(999, context.getPayAmount());
    }
}
```

import TailProtocal from "@site/src/components/TailProtocal";

<TailProtocal />
