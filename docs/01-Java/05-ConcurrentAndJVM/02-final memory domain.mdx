---
title: final域内存知识
sidebar_label: final域内存知识
---


## final域重排序规则

在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。

初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序

![](https://s2.loli.net/2023/07/15/Da4P5Cl7dFgKYen.png)

假设一个线程A执行writer()方法，随后另一个线程B执行reader()方法

* JMM禁止编译器把final域的写重排序到构造函数之外。
* 编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。

![](https://s2.loli.net/2023/07/15/Sh4OgLmT1iNGFCf.png)

读到普通变量初始化之前的值

![](https://s2.loli.net/2023/07/15/k96DUOV1gT4Ftso.png)

对象的普通域的操作被处理器重排序到读对象引用之前。读普通域时，该域还没有被写线程A写入，这是一个错误的读取操作。而读final域的重排序规则会把读对象final域的操作“限定”在读对象引用之后，此时该final域已经被A线程初始化过了，这是一个正确的读取操作。

## 被final修饰的类型为引用类型

![](https://s2.loli.net/2023/07/15/TLzvsetCf178j59.png)

在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。

* 1是对final域的写入，2是对这个final域引用的对象的成员域的写入，3是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的1不能和3重排序外，2和3也不能重排序。

* JMM可以确保读线程C至少能看到写线程A在构造函数中对final引用对象的成员域的写入。即C至少能看到数组下标0的值为1。而写线程B对数组元素的写入，读线程C可能看得到，也可能看不到。JMM不保证线程B的写入对读线程C
  可见，因为写线程B和读线程C之间存在数据竞争，此时的执行结果不可预知。

* 如果想要确保读线程C看到写线程B对数组元素的写入，写线程B和读线程C之间需要使用同步原语（lock或volatile）来确保内存可见性。

## 为什么final引用不能从构造函数内溢出

在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了

在构造函数内部，不能让这个被构造对象的引用为其他线程所见，也就是对象引用不能在构造函数中“逸出”。

![](https://s2.loli.net/2023/07/15/iKW2PU6vFrCqVT9.png)

执行read()方法的线程仍然可能无法看到final域被初始化后的值，因为这里的操作1和操作2之间可能被重排序。

![](https://s2.loli.net/2023/07/15/w8cFmhtjfQYyk49.png)

***

![](https://s2.loli.net/2023/07/15/H7jnLcbMDz2WUhi.png)

## final语义在处理器中的实现

写final域的重排序规则会要求编译器在final域的写之后，构造函数return之前插入一个StoreStore障屏。读final域的重排序规则要求编译器在读final域的操作前面插入一个LoadLoad屏障。由于X86处理器不会对写-写操作做重排序，所以在X86处理器中，写final域需要的StoreStore障屏会被省略掉。同样，由于X86处理器不会对存在间接依赖关系的操作做重排序，所以在X86处理器中，读final域需要的LoadLoad屏障也会被省略掉。也就是说，在X86处理器中，final域的读/写不会插入任何内存屏障！(在x86处理器中仅有StoreLoad屏障)



import TailProtocal from "@site/src/components/TailProtocal";

<TailProtocal />
