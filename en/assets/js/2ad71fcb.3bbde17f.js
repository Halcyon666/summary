"use strict";(self.webpackChunksummary=self.webpackChunksummary||[]).push([["8070"],{90315(e,t,n){n.r(t),n.d(t,{metadata:()=>i,default:()=>h,frontMatter:()=>s,contentTitle:()=>c,toc:()=>d,assets:()=>l});var i=JSON.parse('{"id":"background/Java/Spring/AOP/pointcut","title":"Pointcut in Spring AOP","description":"Please refer to [spring-framework](https://github.com/Halcyon666/spring-framework-modified/tree/main/spring-test) for code related to this article (from official source spring-test module)","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/background/Java/Spring/AOP/pointcut.mdx","sourceDirName":"background/Java/Spring/AOP","slug":"/background/Java/Spring/AOP/pointcut","permalink":"/en/background/Java/Spring/AOP/pointcut","draft":false,"unlisted":false,"editUrl":"https://github.com/Halcyon666/summary/edit/main/docs/background/Java/Spring/AOP/pointcut.mdx","tags":[{"inline":true,"label":"algorithm","permalink":"/en/tags/algorithm"},{"inline":true,"label":"computer-science","permalink":"/en/tags/computer-science"},{"inline":true,"label":"data-structures","permalink":"/en/tags/data-structures"}],"version":"current","lastUpdatedBy":"halcyon666","lastUpdatedAt":1769299200000,"sidebarPosition":10,"frontMatter":{"id":"pointcut","title":"Pointcut in Spring AOP","sidebar_label":"Pointcut in Spring AOP","sidebar_position":10,"description":"Please refer to [spring-framework](https://github.com/Halcyon666/spring-framework-modified/tree/main/spring-test) for code related to this article (from official source spring-test module)","tags":["algorithm","computer-science","data-structures"],"last_update":{"date":"2026-01-25","author":"halcyon666"},"sources":["spring-core"]},"sidebar":"tutorialSidebar","previous":{"title":"Joinpoint","permalink":"/en/background/Java/Spring/AOP/joinpoint"},"next":{"title":"Schema-based AOP Configuration","permalink":"/en/background/Java/Spring/AOP/schema-configuration"}}'),o=n(62615),a=n(77545),r=n(4040);let s={id:"pointcut",title:"Pointcut in Spring AOP",sidebar_label:"Pointcut in Spring AOP",sidebar_position:10,description:"Please refer to [spring-framework](https://github.com/Halcyon666/spring-framework-modified/tree/main/spring-test) for code related to this article (from official source spring-test module)",tags:["algorithm","computer-science","data-structures"],last_update:{date:"2026-01-25",author:"halcyon666"},sources:["spring-core"]},c,l={},d=[{value:"NameMatchMethodPointcut",id:"namematchmethodpointcut",level:2},{value:"JdkRegexpMethodPointcut and Perl5RegexpMethodPointcut",id:"jdkregexpmethodpointcut-and-perl5regexpmethodpointcut",level:2},{value:"AnnotationMatchingPointcut",id:"annotationmatchingpointcut",level:2},{value:"ComposablePointcut",id:"composablepointcut",level:2},{value:"ControlFlowPointcut",id:"controlflowpointcut",level:2}];function p(e){let t={a:"a",code:"code",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components},{Details:n}=t;return n||function(e,t){throw Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["Please refer to ",(0,o.jsx)(t.a,{href:"https://github.com/Halcyon666/spring-framework-modified/tree/main/spring-test",children:"spring-framework"})," under ",(0,o.jsx)(t.code,{children:"org.springframework.mylearntest"})," package for code related to this article (from ",(0,o.jsx)(t.a,{href:"https://github.com/spring-projects/spring-framework.git",title:"official source",children:"official source"})," spring-test module)."]}),"\n",(0,o.jsxs)(t.p,{children:["If Pointcut type is ",(0,o.jsx)(t.code,{children:"TruePointcut"}),", it defaults to match all objects in system, and all supported Joinpoints on objects."]}),"\n",(0,o.jsxs)(n,{children:[(0,o.jsx)("summary",{children:"Pointcut"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:"package org.springframework.aop;\n\npublic interface Pointcut {\n\n    ClassFilter getClassFilter();\n\n    MethodMatcher getMethodMatcher();\n\n    Pointcut TRUE = TruePointcut.INSTANCE;\n\n}\n"})})]}),"\n",(0,o.jsxs)(n,{children:[(0,o.jsx)("summary",{children:"TruePointcut"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:'package org.springframework.aop;\n\nimport java.io.Serializable;\n\n@SuppressWarnings("serial")\nfinal class TruePointcut implements Pointcut, Serializable {\n\n    public static final TruePointcut INSTANCE = new TruePointcut();\n\n    private TruePointcut() {\n    }\n\n    @Override\n    public ClassFilter getClassFilter() {\n        return ClassFilter.TRUE;\n    }\n\n    @Override\n    public MethodMatcher getMethodMatcher() {\n        return MethodMatcher.TRUE;\n    }\n\n    private Object readResolve() {\n        return INSTANCE;\n    }\n\n    @Override\n    public String toString() {\n        return "Pointcut.TRUE";\n    }\n\n}\n'})})]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"ClassFilter"})," and ",(0,o.jsx)(t.code,{children:"MethodMatcher"})," are used to match objects and corresponding methods where weaving operations will be performed respectively. Reason for separating type matching and method matching definition is that matching definitions of different levels can be reused, and combination operations can be performed on different levels or same level, or force a subclass to only Override corresponding method definition etc."]}),"\n",(0,o.jsxs)(n,{children:[(0,o.jsx)("summary",{children:"ClassFilter"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:"package org.springframework.aop;\n\n@FunctionalInterface\npublic interface ClassFilter {\n\n    boolean matches(Class<?> clazz);\n\n    ClassFilter TRUE = TrueClassFilter.INSTANCE;\n\n}\n"})})]}),"\n",(0,o.jsxs)(n,{children:[(0,o.jsx)("summary",{children:"MethodMatcher"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:"package org.springframework.aop;\n\nimport java.lang.reflect.Method;\n\npublic interface MethodMatcher {\n\n    boolean matches(Method method, Class<?> targetClass);\n\n    boolean isRuntime();\n\n    boolean matches(Method method, Class<?> targetClass, Object... args);\n\n    MethodMatcher TRUE = TrueMethodMatcher.INSTANCE;\n\n}\n"})})]}),"\n",(0,o.jsxs)(t.p,{children:["When ",(0,o.jsx)(t.code,{children:"isRuntime"})," returns false, it indicates that method arguments of concrete Joinpoint will not be considered, ",(0,o.jsx)(t.code,{children:"MethodMatcher"})," of this type is called staticMethodMatcher. Because there is no need to check arguments every time, matching results for same type of methods can be cached inside framework to improve performance."]}),"\n",(0,o.jsxs)(t.p,{children:["When ",(0,o.jsx)(t.code,{children:"isRuntime"})," returns true, it indicates that ",(0,o.jsx)(t.code,{children:"MethodMatcher"})," will check method call arguments for matching every time, ",(0,o.jsx)(t.code,{children:"MethodMatcher"})," of this type is called ",(0,o.jsx)(t.code,{children:"DynamicMethodMatcher"}),". Because method arguments need to be checked every time, matching results cannot be cached, so matching efficiency is poorer compared to ",(0,o.jsx)(t.code,{children:"StaticMethodMatcher"}),". And in most cases, ",(0,o.jsx)(t.code,{children:"staticMethodMatcher"})," can already satisfy needs. It is best to avoid using ",(0,o.jsx)(t.code,{children:"DynamicMethodMatcher"})," type."]}),"\n",(0,o.jsxs)(t.p,{children:["If ",(0,o.jsx)(t.code,{children:"boolean matches(Method method, Class<?> targetClass);"})," returns true, matches with three arguments will be executed to further check matching conditions; if ",(0,o.jsx)(t.code,{children:"boolean matches(Method method, Class<?> targetClass);"})," returns false, then regardless of whether this ",(0,o.jsx)(t.code,{children:"MethodMatcher"})," is ",(0,o.jsx)(t.code,{children:"staticMethodMatcher"})," or ",(0,o.jsx)(t.code,{children:"DynamicMethodMatcher"}),", this result is already final result, method with three arguments will definitely not be executed."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{src:"https://s2.loli.net/2023/07/15/joCBcvwn5NIWsVP.png",alt:""})}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{src:"https://s2.loli.net/2023/07/15/3TktmhvxbHauZI2.png",alt:"Common pointcut",title:"Common pointcut"})}),"\n",(0,o.jsx)(t.h2,{id:"namematchmethodpointcut",children:"NameMatchMethodPointcut"}),"\n",(0,o.jsxs)(t.p,{children:["Simples Pointcut implementation, belongs to subclass of ",(0,o.jsx)(t.code,{children:"StaticMethodMatcherPointcut"}),", can match based on a set of method names specified by itself against method name at Joinpoint."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'NameMatchMethodPointcut pointcut = new NameMatchMethodPointcut();\npointcut.setMappedName("matches");\n// Or pass multiple method names\npointcut.setMappedNames(new String[]{"matches", "isRuntime"});\n// Simple fuzzy matching\npointcut.setMappedNames(new String[]{"match*", "matches", "mat*es" });\n'})}),"\n",(0,o.jsx)(t.p,{children:"This method cannot match overloaded method names, because it only matches method names, does not consider parameter related information, and also does not provide a way to specify parameter matching information."}),"\n",(0,o.jsx)(t.h2,{id:"jdkregexpmethodpointcut-and-perl5regexpmethodpointcut",children:"JdkRegexpMethodPointcut and Perl5RegexpMethodPointcut"}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"StaticMethodMatcherPointcut"}),"'s subclass has a branch specially providing regular expression based implementation, commanded by abstract class ",(0,o.jsx)(t.code,{children:"AbstractRegexpMethodPointcut"}),", declaring ",(0,o.jsx)(t.code,{children:"pattern"})," and ",(0,o.jsx)(t.code,{children:"patterns"})," properties, can specify one or more regular expression matching patterns. Under it there are two concrete implementations ",(0,o.jsx)(t.code,{children:"SdkRegexpMethodPointcut"})," (likely meaning JdkRegexpMethodPointcut) and ",(0,o.jsx)(t.code,{children:"Perl5RegexpMethodPointcut"}),".\n",(0,o.jsx)(t.code,{children:"JdkRegexpMethodPointcut"})," is JDK standard regular expression introduced after JDK 1.4."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'JdkRegexpMethodPointcut pointcut = new JdkRegexpMethodPointcut();\npointcut.setPattern(".*match.*");\npointcut.setPatterns(new String[]{".*match.", ".*matches"});\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Note that regular expression matching pattern must be specified in form matching entire method signature (Method signature), and cannot just give matching method name part like ",(0,o.jsx)(t.code,{children:"NameMatchMethodPointcut"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"Perl5RegexpMethodPointcut"})," implementation uses ",(0,o.jsx)(t.a,{href:"https://jakarta.apache.org/oro/",children:"Jakarta ORO"})," to provide regular expression support."]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["Can specify one or more regular expressions via ",(0,o.jsx)(t.code,{children:"pattern"})," or ",(0,o.jsx)(t.code,{children:"patterns"})," object properties"]}),"\n",(0,o.jsx)(t.li,{children:"Specified regular expression matching pattern should cover matching entire method signature, rather than just specifying method name part."}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"annotationmatchingpointcut",children:"AnnotationMatchingPointcut"}),"\n",(0,o.jsxs)(n,{children:[(0,o.jsx)("summary",{children:"ClassLevelAnnotation"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:"package org.springframework.mylearntest.aop.annotationmatchingpointcut;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface ClassLevelAnnotation {\n}\n"})})]}),"\n",(0,o.jsxs)(n,{children:[(0,o.jsx)("summary",{children:"MethodLevelAnnotation"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:"package org.springframework.mylearntest.aop.annotationmatchingpointcut;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface MethodLevelAnnotation {\n}\n"})})]}),"\n",(0,o.jsxs)(n,{children:[(0,o.jsx)("summary",{children:"GenericTargetObject"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:'package org.springframework.mylearntest.aop.annotationmatchingpointcut;\n\n@ClassLevelAnnotation\npublic class GenericTargetObject {\n\n    @MethodLevelAnnotation\n    public void getMethod1() {\n        System.out.println("getMethod1");\n    }\n\n    public void getMethod2() {\n        System.out.println("getMethod2");\n    }\n}\n'})})]}),"\n",(0,o.jsxs)(n,{children:[(0,o.jsx)("summary",{children:"How to specify Pointcut"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:"AnnotationMatchingPointcut pointcut = new AnnotationMatchingPointcut(ClassLevelAnnotation.class);\n// Or via static method\nAnnotationMatchingPointcut pointcut1 = AnnotationMatchingPointcut.forClassAnnotation(MethodLevelAnnotation.class);\n// Simultaneous limit\nAnnotationMatchingPointcut pointcut2 = AnnotationMatchingPointcut.forClassAnnotation(ClassLevelAnnotation.class);\n"})})]}),"\n",(0,o.jsx)(t.h2,{id:"composablepointcut",children:"ComposablePointcut"}),"\n",(0,o.jsx)(t.p,{children:'Spring AOP provides Pointcut implementation for Pointcut logic operations. It can perform "Union" and "Intersection" operations between Pointcuts.'}),"\n",(0,o.jsxs)(n,{children:[(0,o.jsx)("summary",{children:"Test4ComposablePointcut"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:"package org.springframework.mylearntest.aop.pointcut.composablePointcut;\n\nimport org.junit.Assert;\nimport org.springframework.aop.ClassFilter;\nimport org.springframework.aop.MethodMatcher;\nimport org.springframework.aop.Pointcut;\nimport org.springframework.aop.support.ComposablePointcut;\nimport org.springframework.aop.support.Pointcuts;\n\npublic class Test4ComposablePointcut {\n\n    public static void main(String[] args) {\n        ComposablePointcut pointcut1 = new ComposablePointcut(new ClassFilter() {\n            @Override\n            public boolean matches(Class<?> clazz) {\n                return false;\n            }\n        }, MethodMatcher.TRUE);\n\n        ComposablePointcut pointcut2 = new ComposablePointcut(new ClassFilter() {\n            @Override\n            public boolean matches(Class<?> clazz) {\n                return false;\n            }\n        }, MethodMatcher.TRUE);\n\n        // union intersection\n        ComposablePointcut union = pointcut1.union(pointcut2);\n        ComposablePointcut intersection = pointcut1.intersection(union);\n\n        Assert.assertEquals(pointcut1,intersection);\n\n        // combine classFilter with methodMatcher\n        pointcut2.union(new ClassFilter() {\n            @Override\n            public boolean matches(Class<?> clazz) {\n                return false;\n            }\n        }).intersection(MethodMatcher.TRUE);\n\n        // just compute between pointcut, use org.springframework.aop.support.Pointcuts\n        Pointcut pointcut3 = new Pointcut() {\n            @Override\n            public ClassFilter getClassFilter() {\n                return null;\n            }\n\n            @Override\n            public MethodMatcher getMethodMatcher() {\n                return null;\n            }\n        };\n\n        Pointcut pointcut4 = new Pointcut() {\n            @Override\n            public ClassFilter getClassFilter() {\n                return null;\n            }\n\n            @Override\n            public MethodMatcher getMethodMatcher() {\n                return null;\n            }\n        };\n        \n        Pointcut union1 = Pointcuts.union(pointcut3, pointcut4);\n        Pointcut intersection1 = Pointcuts.intersection(pointcut3, pointcut4);\n\n    }\n}\n"})})]}),"\n",(0,o.jsx)(t.h2,{id:"controlflowpointcut",children:"ControlFlowPointcut"}),"\n",(0,o.jsx)(t.p,{children:"ControlFlowPointcut matches the program's calling flow, it does not match a single feature at the Joinpoint where a method execution is located, but intercepts method only when executed by a specific class.\nBecause ControlFlowPointcut type Pointcut needs to check program's calling stack during runtime, and needs to check every time method is called, so performance is relatively poor."}),"\n","\n",(0,o.jsx)(r.A,{})]})}function h(e={}){let{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}}}]);