"use strict";(self.webpackChunksummary=self.webpackChunksummary||[]).push([[6911],{5790:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var o=n(5893),i=n(1151);const a={title:"Point in Spring AOP",sidebar_label:"Point in Spring AOP",sidebar_position:8},r=void 0,s={id:"Java/Spring/Spring AOP Pointcut",title:"Point in Spring AOP",description:"For the relevant code fromOfficial Codebase spring-test) please seespring-framework org.springframe.mylearntest package.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/01-Java/02-Spring/Spring AOP Pointcut.mdx",sourceDirName:"01-Java/02-Spring",slug:"/Java/Spring/Spring AOP Pointcut",permalink:"/en/Java/Spring/Spring AOP Pointcut",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:8,frontMatter:{title:"Point in Spring AOP",sidebar_label:"Point in Spring AOP",sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"Joinpoint",permalink:"/en/Java/Spring/Joinpoint"},next:{title:"Spring AOP\u4e2d\u7684Advice",permalink:"/en/Java/Spring/Spring AOP Advice"}},c={},l=[{value:"NameMatchMethodPointPut",id:"namematchmethodpointput",level:2},{value:"JdkRegexpMethodPointPut and Perl5RegexpMethodPointPut",id:"jdkregexpmethodpointput-and-perl5regexpmethodpointput",level:2},{value:"AnnotationMatchingPoint",id:"annotationmatchingpoint",level:2},{value:"ComposablePointOut",id:"composablepointout",level:2},{value:"ControlFlowPointPut",id:"controlflowpointput",level:2}];function h(e){const t={a:"a",code:"code",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components},{Details:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["For the relevant code from",(0,o.jsx)(t.a,{href:"https://github.com/spring-projects/spring-framework.git",title:"official source",children:"Official Codebase"})," spring-test) please see",(0,o.jsx)(t.a,{href:"https://github.com/Halcyon66/spring-frame-modified/tree/main/spring-test",children:"spring-framework"})," org.springframe.mylearntest package."]}),"\n",(0,o.jsx)(t.p,{children:"If TruePoint type is TruePointcut, all objects in the system and all supported Joinpoint on the object will be matched by default."}),"\n",(0,o.jsxs)(n,{children:[(0,o.jsx)("summary",{children:"Pointcut"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:"package org.springframe.aop;\n\npublic interface Pointcut {LO\n\n    ClassFilter getClassFilter();\n\n    MethodMatcher getMethodMatcher();\n\n    Pointet TRUE = TruePointcut.INSTRA;\n\n } } }\n"})})]}),"\n",(0,o.jsxs)(n,{children:[(0,o.jsx)("summary",{children:"Pointcut"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:'package org.springframework.aop;\n\nimport java.io.Serializable;\n\n@SuppressWarnings("serial")\nfinal class TruePointcut implements Pointcut, Serializable {\n\n    public static final TruePointcut INSTANCE = new TruePointcut();\n\n    private TruePointcut() {\n    }\n\n    @Override\n    public ClassFilter getClassFilter() {\n        return ClassFilter.TRUE;\n    }\n\n    @Override\n    public MethodMatcher getMethodMatcher() {\n        return MethodMatcher.TRUE;\n    }\n\n    private Object readResolve() {\n        return INSTANCE;\n    }\n\n    @Override\n    public String toString() {\n        return "Pointcut.TRUE";\n    }\n\n}\n'})})]}),"\n",(0,o.jsx)(t.p,{children:"ClassFilter and MethodMatcher are used to match objects that will be woven into the operation and the corresponding method.The reason to define types of matching and methods is that they can be redefined in terms of different levels of matching, combined at different levels or at the same level, or force a subcategory to cover only the corresponding parties (Override)."}),"\n",(0,o.jsxs)(n,{children:[(0,o.jsx)("summary",{children:"ClassFilter"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:"package org.springframe.aop;\n\n@FunctionalInterface\npublic interface ClassFilter\n\n    boolean matches, Class<?> clazz;\n\n    ClassFilter TRUE = TrueClassFilter.INSTRAW;\n\n}\n"})})]}),"\n",(0,o.jsxs)(n,{children:[(0,o.jsx)("summary",{children:"MethodMatcher"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:"package org.springframe.aop;\n\nimport java.lang.reflect. ethod;\n\npublic interface MethodMatcher LO\n\n    boolean matches (Method method, Class<? targetClass);\n\n    boolean isRuntime();\n\n    boolean matches (Methodology method, Class<?> targetClasss, Object. . args);\n\n    MethodMatcher TRUE = TrueMethodMatcher.INSTRAE;\n\n}\n"})})]}),"\n",(0,o.jsx)(t.p,{children:"When isRuntime returns false, it does not consider specific Joinpoint methodological parameters, which MethodMatcher refers to as staticMethodMatcher.Because no parameters are checked every time, the same type of method matches results can be cached inside the framework to improve performance."}),"\n",(0,o.jsx)(t.p,{children:"When isRuntime returns true, it is shown that MethodMatcher will match the parameter called by the method every time this type of MethodMatcher calls it DynamicMethodMatcher.Because methodological parameters are checked every time and the matching results cannot be cached, the matching efficiency is worse than StaticMethodMatcher.And in most sectors, staticMethodMatcher can already meet the needs.It is best to avoid using the Dynamic MethodMatcher type."}),"\n",(0,o.jsxs)(t.p,{children:["If ",(0,o.jsx)(t.code,{children:"boolean matches(Method method, Class<?> targetClass);"}),"When returning to true, the matches of the three parameters will be executed to further check the matches; if ",(0,o.jsx)(t.code,{children:"boolean matches (Method method, Class<?> targetClass);"}),"Returns false, then whether this MethodMatcher is staticMethodMatcher or Dynamic MethodMatcher, the result is already final and the three parameters will certainly not be executed."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{src:"https://s2.loli.net/2023/07/15/joCBcvwn5NWsVP.png",alt:""})}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{src:"https://s2.loli.net/2023/07/15/3TktmhvxbHauZI2.png",alt:"Common pointcut",title:"Common point"})}),"\n",(0,o.jsx)(t.h2,{id:"namematchmethodpointput",children:"NameMatchMethodPointPut"}),"\n",(0,o.jsx)(t.p,{children:"The simplest Pointcut, a subclass in StaticMethodMatcherPointt, can match the method name of the Joinpoint method by assigning a set of method names."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'NameMatchMethodPoint Point pointcut = new NameMatchMethodPointcut();\npoint.setMappedName("matches");\n// or multiple method names\npoint.setMappedName(new String[]{"matches", "isRuntime"});\n// Simply blur matching\npoint.setMappedName(new String[]{"match*", "matches", "mates" });\n'})}),"\n",(0,o.jsx)(t.p,{children:"This method cannot match the reloaded method name because it matches the method name only, does not take into account the parameter information and does not provide a way to specify the parameter matching information."}),"\n",(0,o.jsx)(t.h2,{id:"jdkregexpmethodpointput-and-perl5regexpmethodpointput",children:"JdkRegexpMethodPointPut and Perl5RegexpMethodPointPut"}),"\n",(0,o.jsx)(t.p,{children:"A subclass of StaticMethodMatcherPointcut is dedicated to providing an implementation branch based on regular expressions, led by an abstract type AbstractRegexpMethodPointcut, which states pattern and pattern properties, and can specify a matching pattern or multiple regular expressions.These are implemented in JdkRegexpMethodPointPut and Perl5RegexpMethodPoints."}),"\n",(0,o.jsx)(t.p,{children:"JdkRegexpMethodPointPut is the introduction of a JDK standard regular expression after JDK 1.4."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'JdkRegexpMethodPoint Pointcut = new JdkRegexpMethodMethodPointcut();\npoint.setPattern(".*match.*");\npointcut.setPatterns(new String[]{".*match.", ".*mates"});\n'})}),"\n",(0,o.jsx)(t.p,{children:"Note that the regular expression matching pattern must match the signature of the entire method, but not just the matching method name, as NameMatchMethodPointcut."}),"\n",(0,o.jsxs)(t.p,{children:["Perl5RegexpMethodPointPut implements regular expression support using ",(0,o.jsx)(t.a,{href:"https://jakarta.apache.org/oro/",children:"Jakarta ORO"})]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"One or more regular expressions can be specified by pattern or pattern object properties"}),"\n",(0,o.jsx)(t.li,{children:"Specifies the regular expression matching mode to override the signature of the matching method, not just to the method name section."}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"annotationmatchingpoint",children:"AnnotationMatchingPoint"}),"\n",(0,o.jsxs)(n,{children:[(0,o.jsx)("summary",{children:"ClassLevelAnnotation"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:"package org.springframe.mylearntest.aop.annotationmatchingpoint;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\nRetention(RetentionPolicy.RUNTIME)\nTarget(ElementType.TYPE)\npublic @interface ClassLevelAnnotation\n}\n"})})]}),"\n",(0,o.jsxs)(n,{children:[(0,o.jsx)("summary",{children:"MethodLevelAnnotation"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:"package org.springframe.mylearntest.aop.annotationmatchingpoint;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\nRetention(RetentionPolicy.RUNTIME)\nTarget(ElementType.METHOD)\npublic @face MethodLevelAnnotation\n}\n"})})]}),"\n",(0,o.jsxs)(n,{children:[(0,o.jsx)("summary",{children:"GenericTargetObject"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:'package org.springframework.mylearntest.aop.annotationmatchingpointcut;\n\n@ClassLevelAnnotation\npublic class GenericTargetObject {\n\n    @MethodLevelAnnotation\n    public void getMethod1() {\n        System.out.println("getMethod1");\n    }\n\n    public void getMethod2() {\n        System.out.println("getMethod2");\n    }\n}\n'})})]}),"\n",(0,o.jsxs)(n,{children:[(0,o.jsx)("summary",{children:"how to specify Pointcut"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:"AnnotationMatchingPoint point = new AnnotationMatchingPointcut (ClassLevelAnnotation.class);\n// can also be done by static method\nAnnotationMatchingPoint point1 = AnnotationMatchingPointcut.forClassAnnotation(MethodLevelAnnotation.class);\n// also limited\nAnnotationMatchingPointpoint2 = AnnotationMatchingPointcut.forClassAnnotation(ClassLevelAnnotation.class);\n"})})]}),"\n",(0,o.jsx)(t.h2,{id:"composablepointout",children:"ComposablePointOut"}),"\n",(0,o.jsx)(t.p,{children:"Spring AOP provides Pointcut logic implementationIt can perform \u201cand\u201d and \u201cdeal\u201d operations between Pointcut."}),"\n",(0,o.jsxs)(n,{children:[(0,o.jsx)("summary",{children:"Test4ComposablePointcut"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:"package org.springframework.mylearntest.aop.pointcut.composablePointcut;\n\nimport org.junit.Assert;\nimport org.springframework.aop.ClassFilter;\nimport org.springframework.aop.MethodMatcher;\nimport org.springframework.aop.Pointcut;\nimport org.springframework.aop.support.ComposablePointcut;\nimport org.springframework.aop.support.Pointcuts;\n\npublic class Test4ComposablePointcut {\n\n    public static void main(String[] args) {\n        ComposablePointcut pointcut1 = new ComposablePointcut(new ClassFilter() {\n            @Override\n            public boolean matches(Class<?> clazz) {\n                return false;\n            }\n        }, MethodMatcher.TRUE);\n\n        ComposablePointcut pointcut2 = new ComposablePointcut(new ClassFilter() {\n            @Override\n            public boolean matches(Class<?> clazz) {\n                return false;\n            }\n        }, MethodMatcher.TRUE);\n\n        // union intersection\n        ComposablePointcut union = pointcut1.union(pointcut2);\n        ComposablePointcut intersection = pointcut1.intersection(union);\n\n        Assert.assertEquals(pointcut1,intersection);\n\n        // combine classFilter with methodMatcher\n        pointcut2.union(new ClassFilter() {\n            @Override\n            public boolean matches(Class<?> clazz) {\n                return false;\n            }\n        }).intersection(MethodMatcher.TRUE);\n\n        // just compute between pointcut, use org.springframework.aop.support.Pointcuts\n        Pointcut pointcut3 = new Pointcut() {\n            @Override\n            public ClassFilter getClassFilter() {\n                return null;\n            }\n\n            @Override\n            public MethodMatcher getMethodMatcher() {\n                return null;\n            }\n        };\n\n        Pointcut pointcut4 = new Pointcut() {\n            @Override\n            public ClassFilter getClassFilter() {\n                return null;\n            }\n\n            @Override\n            public MethodMatcher getMethodMatcher() {\n                return null;\n            }\n        };\n        \n        Pointcut union1 = Pointcuts.union(pointcut3, pointcut4);\n        Pointcut intersection1 = Pointcuts.intersection(pointcut3, pointcut4);\n\n    }\n}\n"})})]}),"\n",(0,o.jsx)(t.h2,{id:"controlflowpointput",children:"ControlFlowPointPut"}),"\n",(0,o.jsx)(t.p,{children:"The control FlowPointMatch process does not match a single feature in the Joinpoint where a method executes but will not be intercepted by a particular class.\nPointcut, of the ControlFlowPointPut type, requires checking the call stack during operation and every method call."})]})}function p(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>s,a:()=>r});var o=n(7294);const i={},a=o.createContext(i);function r(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(a.Provider,{value:t},e.children)}}}]);