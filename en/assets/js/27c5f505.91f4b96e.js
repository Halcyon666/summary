"use strict";(self.webpackChunksummary=self.webpackChunksummary||[]).push([["1273"],{12358(e,r,t){t.r(r),t.d(r,{metadata:()=>n,default:()=>h,frontMatter:()=>s,contentTitle:()=>d,toc:()=>c,assets:()=>l});var n=JSON.parse('{"id":"background/Java/Concurrent-JVM/final-memory-domain","title":"Final Field Memory Knowledge","description":"A write to a final field inside a constructor and the subsequent assignment of the reference of the constructed object to a reference variable cannot be reordered. The first read of a reference to an object containing a final field and the subsequent first read of this final field cannot be reordered.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/background/Java/Concurrent-JVM/final memory domain.mdx","sourceDirName":"background/Java/Concurrent-JVM","slug":"/background/Java/Concurrent-JVM/final-memory-domain","permalink":"/en/background/Java/Concurrent-JVM/final-memory-domain","draft":false,"unlisted":false,"editUrl":"https://github.com/Halcyon666/summary/edit/main/docs/background/Java/Concurrent-JVM/final memory domain.mdx","tags":[{"inline":true,"label":"algorithm","permalink":"/en/tags/algorithm"},{"inline":true,"label":"computer-science","permalink":"/en/tags/computer-science"},{"inline":true,"label":"data-structures","permalink":"/en/tags/data-structures"}],"version":"current","lastUpdatedBy":"halcyon666","lastUpdatedAt":1769299200000,"sidebarPosition":10,"frontMatter":{"id":"final-memory-domain","title":"Final Field Memory Knowledge","sidebar_label":"Final Field Memory Knowledge","sidebar_position":10,"description":"A write to a final field inside a constructor and the subsequent assignment of the reference of the constructed object to a reference variable cannot be reordered. The first read of a reference to an object containing a final field and the subsequent first read of this final field cannot be reordered.","tags":["algorithm","computer-science","data-structures"],"last_update":{"date":"2026-01-25","author":"halcyon666"},"sources":["spring-core"]},"sidebar":"tutorialSidebar","previous":{"title":"Java Concurrent Programming","permalink":"/en/background/Java/Concurrent-JVM/java-concurrent-cases"},"next":{"title":"Lock","permalink":"/en/background/Java/Concurrent-JVM/lock"}}'),i=t(62615),a=t(77545),o=t(4040);let s={id:"final-memory-domain",title:"Final Field Memory Knowledge",sidebar_label:"Final Field Memory Knowledge",sidebar_position:10,description:"A write to a final field inside a constructor and the subsequent assignment of the reference of the constructed object to a reference variable cannot be reordered. The first read of a reference to an object containing a final field and the subsequent first read of this final field cannot be reordered.",tags:["algorithm","computer-science","data-structures"],last_update:{date:"2026-01-25",author:"halcyon666"},sources:["spring-core"]},d,l={},c=[{value:"Final Field Reordering Rules",id:"final-field-reordering-rules",level:2},{value:"Type Modified by Final is Reference Type",id:"type-modified-by-final-is-reference-type",level:2},{value:"Why Final Reference Cannot Escape from Constructor",id:"why-final-reference-cannot-escape-from-constructor",level:2},{value:"Implementation of Final Semantics in Processors",id:"implementation-of-final-semantics-in-processors",level:2}];function f(e){let r={h2:"h2",hr:"hr",img:"img",li:"li",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.h2,{id:"final-field-reordering-rules",children:"Final Field Reordering Rules"}),"\n",(0,i.jsx)(r.p,{children:"A write to a final field inside a constructor and the subsequent assignment of the reference of the constructed object to a reference variable cannot be reordered."}),"\n",(0,i.jsx)(r.p,{children:"The first read of a reference to an object containing a final field and the subsequent first read of this final field cannot be reordered."}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{src:"https://s2.loli.net/2023/07/15/Da4P5Cl7dFgKYen.png",alt:""})}),"\n",(0,i.jsx)(r.p,{children:"Assume thread A executes writer() method, and subsequently another thread B executes reader() method."}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"JMM prohibits compilers from reordering writes to final fields outside of the constructor."}),"\n",(0,i.jsx)(r.li,{children:"The compiler will insert a StoreStore barrier after the write of a final field and before the constructor returns. This barrier prohibits the processor from reordering the write of the final field outside of the constructor."}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{src:"https://s2.loli.net/2023/07/15/Sh4OgLmT1iNGFCf.png",alt:""})}),"\n",(0,i.jsx)(r.p,{children:"Read value before ordinary variable initialization"}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{src:"https://s2.loli.net/2023/07/15/k96DUOV1gT4Ftso.png",alt:""})}),"\n",(0,i.jsx)(r.p,{children:'Operations on ordinary fields of an object are reordered by the processor to before reading the object reference. When reading the ordinary field, the field has not yet been written by write thread A; this is an erroneous read operation. However, the reordering rules for reading final fields "confine" the operation of reading the object\'s final field to after reading the object reference. At this time, the final field has already been initialized by thread A; this is a correct read operation.'}),"\n",(0,i.jsx)(r.h2,{id:"type-modified-by-final-is-reference-type",children:"Type Modified by Final is Reference Type"}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{src:"https://s2.loli.net/2023/07/15/TLzvsetCf178j59.png",alt:""})}),"\n",(0,i.jsx)(r.p,{children:"A write to a member field of an object referenced by a final field inside a constructor and the subsequent assignment of the reference of the constructed object to a reference variable outside the constructor cannot be reordered."}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"1 is the write to the final field, 2 is the write to the member field of the object referenced by this final field, and 3 is the assignment of the reference of the constructed object to a reference variable. Here, besides the aforementioned rule that 1 cannot be reordered with 3, 2 and 3 also cannot be reordered."}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"JMM can ensure that read thread C can at least see the write by write thread A to the member field of the final referenced object in the constructor. That is, C can at least see that the value of array index 0 is 1. As for the write by write thread B to array elements, read thread C may or may not see it. JMM does not guarantee that thread B's write is visible to read thread C because there is a data race between write thread B and read thread C, and the execution result at this time is unpredictable."}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"If you want to ensure that read thread C sees the write by write thread B to array elements, synchronization primitives (lock or volatile) need to be used between write thread B and read thread C to ensure memory visibility."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"why-final-reference-cannot-escape-from-constructor",children:"Why Final Reference Cannot Escape from Constructor"}),"\n",(0,i.jsx)(r.p,{children:"Before the reference variable becomes visible to any thread, the final fields of the object pointed to by the reference variable have already been correctly initialized in the constructor."}),"\n",(0,i.jsx)(r.p,{children:'Inside the constructor, the reference of the constructed object cannot be seen by other threads, meaning the object reference cannot "escape" from the constructor.'}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{src:"https://s2.loli.net/2023/07/15/iKW2PU6vFrCqVT9.png",alt:""})}),"\n",(0,i.jsx)(r.p,{children:"The thread executing the read() method may still be unable to see the value of the final field after initialization because operation 1 and operation 2 may be reordered."}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{src:"https://s2.loli.net/2023/07/15/w8cFmhtjfQYyk49.png",alt:""})}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{src:"https://s2.loli.net/2023/07/15/H7jnLcbMDz2WUhi.png",alt:""})}),"\n",(0,i.jsx)(r.h2,{id:"implementation-of-final-semantics-in-processors",children:"Implementation of Final Semantics in Processors"}),"\n",(0,i.jsx)(r.p,{children:"The reordering rule for writing final fields requires the compiler to insert a StoreStore barrier after the write of a final field and before the constructor returns. The reordering rule for reading final fields requires the compiler to insert a LoadLoad barrier before the operation of reading a final field. Since X86 processors do not reorder write-write operations, the StoreStore barrier required for writing final fields will be omitted in X86 processors. Similarly, since X86 processors do not reorder operations with indirect dependencies, the LoadLoad barrier required for reading final fields will also be omitted in X86 processors. That is to say, in X86 processors, reads/writes of final fields will not insert any memory barriers! (Only StoreLoad barriers exist in X86 processors)"}),"\n","\n",(0,i.jsx)(o.A,{})]})}function h(e={}){let{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(f,{...e})}):f(e)}}}]);