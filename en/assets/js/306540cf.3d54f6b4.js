"use strict";(self.webpackChunksummary=self.webpackChunksummary||[]).push([["2539"],{99926(e,n,i){i.r(n),i.d(n,{metadata:()=>t,default:()=>h,frontMatter:()=>a,contentTitle:()=>c,toc:()=>d,assets:()=>l});var t=JSON.parse('{"id":"background/Java/Spring/Core/spring-core","title":"Spring Core","description":"Please refer to [spring-framework](https://github.com/Halcyon666/spring-framework-modified/tree/main/spring-test) for code related to this article (from official source spring-test module)","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/background/Java/Spring/Core/spring-core.mdx","sourceDirName":"background/Java/Spring/Core","slug":"/background/Java/Spring/Core/spring-core","permalink":"/en/background/Java/Spring/Core/spring-core","draft":false,"unlisted":false,"editUrl":"https://github.com/Halcyon666/summary/edit/main/docs/background/Java/Spring/Core/spring-core.mdx","tags":[{"inline":true,"label":"algorithm","permalink":"/en/tags/algorithm"},{"inline":true,"label":"computer-science","permalink":"/en/tags/computer-science"},{"inline":true,"label":"data-structures","permalink":"/en/tags/data-structures"}],"version":"current","lastUpdatedBy":"halcyon666","lastUpdatedAt":1769299200000,"sidebarPosition":10,"frontMatter":{"id":"spring-core","title":"Spring Core","sidebar_label":"Spring Core","sidebar_position":10,"description":"Please refer to [spring-framework](https://github.com/Halcyon666/spring-framework-modified/tree/main/spring-test) for code related to this article (from official source spring-test module)","tags":["algorithm","computer-science","data-structures"],"last_update":{"date":"2026-01-25","author":"halcyon666"},"sources":["spring-core"]},"sidebar":"tutorialSidebar","previous":{"title":"BeanFactoryPostProcessor","permalink":"/en/background/Java/Spring/Core/bean-factory-post-processor"},"next":{"title":"IoC Injection Methods 2","permalink":"/en/background/Java/Spring/IOC/ioc-advanced"}}'),r=i(62615),s=i(77545),o=i(4040);let a={id:"spring-core",title:"Spring Core",sidebar_label:"Spring Core",sidebar_position:10,description:"Please refer to [spring-framework](https://github.com/Halcyon666/spring-framework-modified/tree/main/spring-test) for code related to this article (from official source spring-test module)",tags:["algorithm","computer-science","data-structures"],last_update:{date:"2026-01-25",author:"halcyon666"},sources:["spring-core"]},c,l={},d=[{value:"Specify a shorter one in a long lifecycle Bean",id:"specify-a-shorter-one-in-a-long-lifecycle-bean",level:2},{value:"Prototype bean in singleton Bean",id:"prototype-bean-in-singleton-bean",level:2},{value:"<code>@Autowired</code> field underlying implementation",id:"autowired-field-underlying-implementation",level:2},{value:"static @Bean",id:"static-bean",level:2},{value:"<code>@Autowired</code> or <code>@Resource</code> specify implementation class",id:"autowired-or-resource-specify-implementation-class",level:2},{value:"Constructor Injection",id:"constructor-injection",level:2},{value:"Is it better to use AspectJ annotation for AOP configuration or xml",id:"is-it-better-to-use-aspectj-annotation-for-aop-configuration-or-xml",level:2},{value:"Closure and Callback",id:"closure-and-callback",level:2},{value:"<code>@Configurable</code> and <code>@Configuration</code>",id:"configurable-and-configuration",level:2},{value:"Spring Boot Customize an Event Publication",id:"spring-boot-customize-an-event-publication",level:2}];function p(e){let n={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components},{Details:i}=n;return i||function(e,n){throw Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Please refer to ",(0,r.jsx)(n.a,{href:"https://github.com/Halcyon666/spring-framework-modified/tree/main/spring-test",children:"spring-framework"})," under ",(0,r.jsx)(n.code,{children:"org.springframework.mylearntest"})," package for code related to this article (from ",(0,r.jsx)(n.a,{href:"https://github.com/spring-projects/spring-framework.git",title:"official source",children:"official source"})," spring-test module)."]}),"\n",(0,r.jsx)(n.h2,{id:"specify-a-shorter-one-in-a-long-lifecycle-bean",children:"Specify a shorter one in a long lifecycle Bean"}),"\n",(0,r.jsx)(n.p,{children:"lookup-method"}),"\n",(0,r.jsxs)(n.p,{children:["Assuming a singleton Bean A needs to reference another non-singleton Bean B, generally we use set method to populate dependency. But here singleton Bean A and non-singleton Bean B have different lifecycles, how to get a new Bean B every time Bean A logic is executed? Is it possible every time?\nUsing ",(0,r.jsx)(n.code,{children:"lookup-method"})," can solve this problem. ",(0,r.jsx)(n.code,{children:"lookup-method"})," has a prerequisite: Bean A needs to be abstract or corresponding method is abstract."]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsx)("summary",{children:"XML Configuration"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-XML",children:'<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    <bean id="newsBean" class="org.springframework.mylearntest.ioc.lookupMethod.FXNewsBean" scope="prototype">\n    </bean>\n\n    <bean id="mockNewsProvider" class="org.springframework.mylearntest.ioc.lookupMethod.MockNewsPersister">\n        <lookup-method name="getNewsBean" bean="newsBean"/>\n    </bean>\n\n</beans>\n'})})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsx)("summary",{children:"Test Class"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'package org.springframework.mylearntest.ioc.lookupMethod;\n\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class Test4lookupMethod {\n    public static void main(String[] args) {\n        ApplicationContext beanFactory = new ClassPathXmlApplicationContext("ioc/lookup-method.xml");\n        MockNewsPersister mockNewsPersister = (MockNewsPersister) beanFactory.getBean("mockNewsProvider");\n        mockNewsPersister.persistNews();\n        mockNewsPersister.persistNews();\n    }\n}\n'})})]}),"\n",(0,r.jsxs)(n.p,{children:["Spring will use CGLIB dynamically generated subclass to override ",(0,r.jsx)(n.code,{children:"getNewsBean"})," method. Since it is dynamically generated, we naturally can't see the code, but we can verify it by printing class name: ",(0,r.jsx)(n.code,{children:"System.out.println(mockNewsPersister.getClass().getName());"})," result is ",(0,r.jsx)(n.code,{children:"org.springframework.mylearntest.ioc.lookupMethod.MockNewsPersister$$EnhancerBySpringCGLIB$$..."}),". This indicates that MockNewsPersister generated by Spring is indeed CGLIB subclass."]}),"\n",(0,r.jsxs)(n.p,{children:["Actually there is another way, which is to implement ",(0,r.jsx)(n.code,{children:"BeanFactoryAware"})," interface. When a Bean implements ",(0,r.jsx)(n.code,{children:"BeanFactoryAware"})," interface, Spring will inject ",(0,r.jsx)(n.code,{children:"BeanFactory"})," into this Bean during instantiation. Then we can use ",(0,r.jsx)(n.code,{children:"BeanFactory"})," to get Bean B."]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsx)("summary",{children:"Use BeanFactoryAware"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'package org.springframework.mylearntest.ioc.lookupMethod;\n\n\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryAware;\n\npublic class MockNewsPersister implements BeanFactoryAware {\n	private BeanFactory beanFactory;\n\n	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n		this.beanFactory = beanFactory;\n	}\n\n	public void persistNews() {\n		System.out.println("persist news");\n		// Dispatcher\n		getNewsBean();\n	}\n\n	public FXNewsBean getNewsBean() {\n		return (FXNewsBean) beanFactory.getBean("newsBean");\n	}\n}\n'})})]}),"\n",(0,r.jsx)(n.h2,{id:"prototype-bean-in-singleton-bean",children:"Prototype bean in singleton Bean"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\n@Component\npublic class Prototype {\n\n}\n\n@Component\npublic class Singleton {\n\n	@Autowired\n	private Prototype prototype;\n\n	public void print() {\n		System.out.println(prototype);\n	}\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Since ",(0,r.jsx)(n.code,{children:"Singleton"})," Bean is a singleton, it is only initialized once, so ",(0,r.jsx)(n.code,{children:"Prototype"})," Bean will also initialize once. This causes ",(0,r.jsx)(n.code,{children:"Prototype"})," Bean to actually become a singleton. If we want ",(0,r.jsx)(n.code,{children:"Prototype"})," to be initialized anew every time ",(0,r.jsx)(n.code,{children:"print"})," is called, we can use ",(0,r.jsx)(n.code,{children:"ObjectFactory"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"@Component\npublic class Singleton {\n\n	@Autowired\n	private ObjectFactory<Prototype> prototypeObjectFactory;\n\n	public void print() {\n		System.out.println(prototypeObjectFactory.getObject());\n	}\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"ObjectFactory"})," is a functional interface, its implementation class is implicitly implemented by Spring. Its ",(0,r.jsx)(n.code,{children:"getObject"})," method will trigger Spring container to get logic of Bean. If Target Bean is singleton, it returns same instance; if it is prototype, it creates a new instance.\nThere is another way ",(0,r.jsx)(n.code,{children:"ObjectProvider"}),", inherited from ",(0,r.jsx)(n.code,{children:"ObjectFactory"}),", providing more functions (lazy loading, optional injection, stream processing: stream())."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"@Component\npublic class Singleton {\n	@Autowired\n	private ObjectProvider<Prototype> prototypeObjectProvider; // Inherits ObjectFactory\n\n	public void print() {\n		System.out.println(prototypeObjectProvider.getIfAvailable()); // Safe consumption\n		prototypeObjectProvider.stream().forEach(System.out::println);\n	}\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"autowired-field-underlying-implementation",children:[(0,r.jsx)(n.code,{children:"@Autowired"})," field underlying implementation"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"@Autowired"})," annotation is handled by ",(0,r.jsx)(n.code,{children:"AutowiredAnnotationBeanPostProcessor"}),". This Post Processor handles ",(0,r.jsx)(n.code,{children:"@Autowired"})," and ",(0,r.jsx)(n.code,{children:"@Value"})," annotations in ",(0,r.jsx)(n.code,{children:"postProcessProperties"})," method (or ",(0,r.jsx)(n.code,{children:"postProcessPropertyValues"})," in old versions)."]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Lookup Injection Metadata (",(0,r.jsx)(n.code,{children:"InjectionMetadata"}),"):\nWhen Spring creates Bean, it parses all fields and methods of target class via ",(0,r.jsx)(n.code,{children:"findAutowiringMetadata"}),", finding those marked with ",(0,r.jsx)(n.code,{children:"@Autowired"}),". These metadata will be cached to avoid repeated parsing."]}),"\n",(0,r.jsxs)(n.li,{children:["Execute Injection (",(0,r.jsx)(n.code,{children:"InjectedElement"}),"):\nTraverse parsed fields (",(0,r.jsx)(n.code,{children:"AutowiredFieldElement"}),") and methods (",(0,r.jsx)(n.code,{children:"AutowiredMethodElement"}),"), call ",(0,r.jsx)(n.code,{children:"inject"})," method."]}),"\n",(0,r.jsxs)(n.li,{children:["Dependency Lookup (",(0,r.jsx)(n.code,{children:"resolveDependency"}),"):\nInternal call ",(0,r.jsx)(n.code,{children:"DefaultListableBeanFactory.resolveDependency"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"First lookup Bean definition by type (Type)."}),"\n",(0,r.jsxs)(n.li,{children:["If find multiple candidates: determine priority based on ",(0,r.jsx)(n.code,{children:"@Primary"}),", ",(0,r.jsx)(n.code,{children:"@Priority"}),". If still unable to determine, fallback to matching by field name (Name)."]}),"\n",(0,r.jsxs)(n.li,{children:["If still cannot find or ambiguous, throw ",(0,r.jsx)(n.code,{children:"NoSuchBeanDefinitionException"})," or ",(0,r.jsx)(n.code,{children:"NoUniqueBeanDefinitionException"})," (unless marked ",(0,r.jsx)(n.code,{children:"required=false"}),")."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Reflection/MethodHandle Assignment:\nFinally use Java reflection ",(0,r.jsx)(n.code,{children:"field.set(bean, value)"})," or ",(0,r.jsx)(n.code,{children:"method.invoke(bean, value)"})," to complete injection."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"static-bean",children:"static @Bean"}),"\n",(0,r.jsxs)(n.p,{children:["If using ",(0,r.jsx)(n.code,{children:"@Bean"})," in ",(0,r.jsx)(n.code,{children:"@Configuration"})," class, it is usually instance method. But if this method is static, it has special meaning."]}),"\n",(0,r.jsxs)(n.p,{children:["Avoid triggering Configuration Class initialization early:\nCommon ",(0,r.jsx)(n.code,{children:"@Bean"})," method requires container to instantiate ",(0,r.jsx)(n.code,{children:"@Configuration"})," class first, and intercept method calls via CGLIB proxy (to ensure singleton symantics).\nStatic ",(0,r.jsx)(n.code,{children:"@Bean"})," method does not depend on instance of containing class. It can load and generate Bean definition without instantiating Configuration class.\nThis is very careful for initializing early infrastructure Beans (like ",(0,r.jsx)(n.code,{children:"BeanPostProcessor"}),", ",(0,r.jsx)(n.code,{children:"BeanFactoryPostProcessor"}),"). If these Beans are defined as instance methods, it will force Configuration class and other Beans it depends on to initialize prematurely during container startup, which may bypass some PostProcessors processing."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"@Configuration\npublic class AppConfig {\n\n    // Common Bean: requires AppConfig to be instantiated first, controlled by CGLIB proxy\n    @Bean\n    public MyService myService() {\n        return new MyService();\n    }\n\n    // Infrastructure Bean: should define as static\n    // Container loads it without instantiating AppConfig, preventing AppConfig from being processed by existing PostProcessors too early\n    @Bean\n    public static BeanPostProcessor myBeanPostProcessor() {\n        return new MyBeanPostProcessor();\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["CGLIB enhancement failure: static method call will not be intercepted by CGLIB subclass inheriting ",(0,r.jsx)(n.code,{children:"@Configuration"}),", so calling this static method inside another ",(0,r.jsx)(n.code,{children:"@Bean"})," method will strictly execute standard Java method call logic (return new instance directly), instead of getting existing Singleton Bean from container. (Usually we do not call static ",(0,r.jsx)(n.code,{children:"@Bean"})," directly between internal methods, but inject dependencies via method parameters)"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"@Configuration\npublic class InfraConfig {\n    @Bean\n    public static PropertySourcesPlaceholderConfigurer placeholderConfigurer() {\n        return new PropertySourcesPlaceholderConfigurer();\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"autowired-or-resource-specify-implementation-class",children:[(0,r.jsx)(n.code,{children:"@Autowired"})," or ",(0,r.jsx)(n.code,{children:"@Resource"})," specify implementation class"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"@Autowired"})," defaults to matching by type (",(0,r.jsx)(n.code,{children:"byType"}),"). If there are multiple candidates, try to match by name (",(0,r.jsx)(n.code,{children:"byName"}),").\n",(0,r.jsx)(n.code,{children:"@Resource"})," defaults to matching by name (",(0,r.jsx)(n.code,{children:"byName"}),"). If not specified name, fallback to field name matching, then type matching."]}),"\n",(0,r.jsx)(n.p,{children:"How to specify implementation class precisely?"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"@Qualifier + @Autowired"}),": ",(0,r.jsx)(n.code,{children:'@Qualifier("impl1")'})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'@Resource(name="impl1")'}),":"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"@Primary"}),":"]}),"\n",(0,r.jsxs)(n.li,{children:["Generic Injection: ",(0,r.jsx)(n.code,{children:"List<Interface>"}),", ",(0,r.jsx)(n.code,{children:"Map<String, Interface>"})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"constructor-injection",children:"Constructor Injection"}),"\n",(0,r.jsx)(n.p,{children:"Spring 4.3+ recommends constructor injection as best practice."}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Immutability: ",(0,r.jsx)(n.code,{children:"final"})," field can be safely assigned in constructor."]}),"\n",(0,r.jsx)(n.li,{children:"Integrity: Ensure dependent objects are not null when created (Fail Fast)."}),"\n",(0,r.jsxs)(n.li,{children:["Testability: Easy to manually ",(0,r.jsx)(n.code,{children:"new"})," object and pass mock dependencies in Unit Test, no need for reflection or Spring container startup."]}),"\n",(0,r.jsxs)(n.li,{children:["If there is only one constructor, ",(0,r.jsx)(n.code,{children:"@Autowired"})," can be omitted, Spring will automatically use it directly."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"@Service\npublic class OrderService {\n    private final UserService userService; // final, ensures immutability\n\n    // @Autowired // Only one constructor, can emit\n    public OrderService(UserService userService) {\n        this.userService = userService;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"is-it-better-to-use-aspectj-annotation-for-aop-configuration-or-xml",children:"Is it better to use AspectJ annotation for AOP configuration or xml"}),"\n",(0,r.jsx)(n.h2,{id:"closure-and-callback",children:"Closure and Callback"}),"\n",(0,r.jsxs)(n.p,{children:["This part is very abstract, for example ",(0,r.jsx)(n.code,{children:"HibernateTemplate"}),", ",(0,r.jsx)(n.code,{children:"JdbcTemplate"})," etc., they all use Template Method Pattern inside, but they are not pure Template Method Pattern, they use Callback."]}),"\n",(0,r.jsxs)(n.p,{children:["Template Method Pattern:\nDefine steps of an algorithm in parent class, allowing subclasses to provide implementation for one or more steps.\n",(0,r.jsx)(n.code,{children:"HibernateTemplate"})," is not abstract class, but uses Callback to inject change parts into Template.\nWhy do this? Because Java doesn't support passing method as parameter (like C++ function pointer), so can only define an interface, then pass implementation class of this interface."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public void doSomething(Callback callback) {\n    // ... Common logic part 1 (Get connection, start transaction)\n    \n    callback.execute(); // Execute customized logic\n    \n    // ... Common logic part 2 (Commit transaction, close connection, handle exception)\n}\n\npublic interface Callback {\n    void execute();\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"HibernateTemplate Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// HibernateTemplate ensure session open/close\npublic <T> T execute(HibernateCallback<T> action) {\n    Session session = getSession();\n    try {\n        return action.doInHibernate(session); // Callback logic\n    } finally {\n        releaseSession(session);\n    }\n}\n\n// User usages: focus on business logic only\ntemplate.execute(new HibernateCallback<Object>() {\n    public Object doInHibernate(Session session) {\n        return session.load(Person.class, 1);\n    }\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:"Using Callback interface + Anonymous Inner Class (or Lambda) simulates effect of Closure, allowing internal logic to access external variables (in Java need to be final or effectively final)"}),"\n",(0,r.jsxs)(n.h2,{id:"configurable-and-configuration",children:[(0,r.jsx)(n.code,{children:"@Configurable"})," and ",(0,r.jsx)(n.code,{children:"@Configuration"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"@Configuration"}),":\nStandard annotation for Spring Java Config. Indicates this class is a configuration class, containing ",(0,r.jsx)(n.code,{children:"@Bean"})," definition methods. Container will process this class via CGLIB proxy to ensure Bean singleton semantics.\n",(0,r.jsx)(n.code,{children:"@Configurable"}),":\nThis is an annotation provided by Spring AOP (relying on AspectJ Load-Time Weaving or Compile-Time Weaving).\nIts purpose is to: Allow objects NOT managed by Spring (e.g. objects created via ",(0,r.jsx)(n.code,{children:"new"})," manually) to still inject Spring Dependencies!\nWhen you ",(0,r.jsx)(n.code,{children:"new"})," an object marked with ",(0,r.jsx)(n.code,{children:"@Configurable"}),", AspectJ aspect will intercept constructor call, and automatically pull dependencies from Spring context to inject into this new object. This is widely used in Domain Driven Design (DDD) Entity injection Service."]}),"\n",(0,r.jsx)(n.h2,{id:"spring-boot-customize-an-event-publication",children:"Spring Boot Customize an Event Publication"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Define Event"}),"\n",(0,r.jsxs)(n.p,{children:["Inherit ",(0,r.jsx)(n.code,{children:"ApplicationEvent"})," or directly POJO (Spring 4.2+ supports generic event)."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public class MyEvent extends ApplicationEvent {\n    private String content;\n    public MyEvent(Object source, String content) {\n        super(source);\n        this.content = content;\n    }\n    // getters\n}\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Publish Event\nInject ",(0,r.jsx)(n.code,{children:"ApplicationEventPublisher"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"@Service\npublic class MyPublisher {\n    @Autowired\n    private ApplicationEventPublisher publisher;\n\n    public void publish(String msg) {\n        publisher.publishEvent(new MyEvent(this, msg));\n    }\n}\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Listen Event\nUse ",(0,r.jsx)(n.code,{children:"@EventListener"})," annotation on method."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Component\npublic class MyListener {\n    @EventListener\n    public void handleMyEvent(MyEvent event) {\n        System.out.println("Received: " + event.getContent());\n    }\n\n    // Support Async processing (requires @EnableAsync)\n    @Async\n    @EventListener\n    public void handleAsync(MyEvent event) { ... }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"@TransactionalEventListener"}),":\nSpecial listener, can trigger event only after current transaction commits/rollbacks. E.g. send email notification after database save succeeds."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)\npublic void handleAfterCommit(MyEvent event) { ... }\n"})}),"\n"]}),"\n"]}),"\n","\n",(0,r.jsx)(o.A,{})]})}function h(e={}){let{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}}}]);