"use strict";(self.webpackChunksummary=self.webpackChunksummary||[]).push([[3158],{5248:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(758);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}},7241:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"Java/Spring/ApplicationContext","title":"ApplicationContext","description":"The related code for this article (from official source code spring-test module) can be found at spring-framework under the org.springframework.mylearntest package.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/01-Java/02-Spring/ApplicationContext.mdx","sourceDirName":"01-Java/02-Spring","slug":"/Java/Spring/ApplicationContext","permalink":"/summary/en/Java/Spring/ApplicationContext","draft":false,"unlisted":false,"editUrl":"https://github.com/Halcyon666/summary/edit/main/i18n/en/docusaurus-plugin-content-docs/current/01-Java/02-Spring/ApplicationContext.mdx","tags":[],"version":"current","lastUpdatedAt":1753970707000,"sidebarPosition":6,"frontMatter":{"title":"ApplicationContext","sidebar_label":"ApplicationContext","sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Bean\u7684\u6784\u9020\u8fc7\u7a0b","permalink":"/summary/en/Java/Spring/Bean Creating Process"},"next":{"title":"Joinpoint","permalink":"/summary/en/Java/Spring/Joinpoint"}}');var s=t(6070),o=t(5248);const r={title:"ApplicationContext",sidebar_label:"ApplicationContext",sidebar_position:6},a=void 0,c={},l=[{value:"Unified Resource Loading Strategy",id:"unified-resource-loading-strategy",level:2},{value:"Four Loading Methods",id:"four-loading-methods",level:2},{value:"Using ApplicationContext as ResourceLoader",id:"using-applicationcontext-as-resourceloader",level:3},{value:"ResourceLoader Type Injection",id:"resourceloader-type-injection",level:3},{value:"Internationalization Support (i18n MessageSource)",id:"internationalization-support-i18n-messagesource",level:2},{value:"Container Internal Event Publishing",id:"container-internal-event-publishing",level:2},{value:"IoC Related Annotations",id:"ioc-related-annotations",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The related code for this article (from ",(0,s.jsx)(n.a,{href:"https://github.com/spring-projects/spring-framework.git",title:"official source code",children:"official source code"})," spring-test module) can be found at ",(0,s.jsx)(n.a,{href:"https://github.com/Halcyon666/spring-framework-modified/tree/main/spring-test",children:"spring-framework"})," under the org.springframework.mylearntest package."]}),"\n",(0,s.jsx)(n.h2,{id:"unified-resource-loading-strategy",children:"Unified Resource Loading Strategy"}),"\n",(0,s.jsx)(n.p,{children:"Spring proposes a set of resource abstraction and loading strategies based on org.springframework.core.io.Resource and org.springframework.core.io.ResourceLoader interfaces."}),"\n",(0,s.jsx)(n.p,{children:"Resource: The interface can provide corresponding concrete implementations based on different types of resources or different scenarios where resources are located. It can help us query resource status, access resource content, and even create new relative resources based on current resources. We can inherit the org.springframework.core.io.AbstractResource abstract class."}),"\n",(0,s.jsx)(n.p,{children:"ResourceLoader: But how to find and locate these resources should be the responsibility of ResourceLoader. The org.springframework.core.io.ResourceLoader interface is a unified abstraction of resource finding and locating strategies, and specific resource finding and locating strategies are provided by corresponding ResourceLoader implementation classes."}),"\n",(0,s.jsx)(n.p,{children:"DefaultResourceLoader: ResourceLoader has a default implementation class, org.springframework.core.io.DefaultResourceLoader, whose default resource finding processing logic is as follows."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"First check if the resource path starts with the classpath: prefix. If so, try to construct a ClassPathResource type resource and return it."}),"\n",(0,s.jsx)(n.li,{children:"Otherwise, (a) try to locate the resource through URL based on the resource path. If no MalformedURLException is thrown, construct a UrlResource type resource and return it; (b) if still unable to locate the specified resource based on the resource path, delegate to the getResourceByPath(String) method for location. The default implementation logic of DefaultResourceLoader's getResourceByPath(String) method is to construct a ClassPathResource type resource and return it."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://s2.loli.net/2023/07/15/3S4uLnEjAsDTgJa.png",alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://s2.loli.net/2023/07/15/gXVo8SKvnThpwZm.png",alt:""})}),"\n",(0,s.jsx)(n.h2,{id:"four-loading-methods",children:"Four Loading Methods"}),"\n",(0,s.jsx)(n.h3,{id:"using-applicationcontext-as-resourceloader",children:"Using ApplicationContext as ResourceLoader"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:'ResourceLoader resourceLoader = new ClassPathXmlApplicationContext("configuration file path");'})}),"\n",(0,s.jsx)(n.h3,{id:"resourceloader-type-injection",children:"ResourceLoader Type Injection"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Depending on ResourceLoader"}),"\n"]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"resourceloader.xml "}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-XML",children:'<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n\t<bean id="resourceLoader" class="org.springframework.core.io.DefaultResourceLoader">\n\t</bean>\n\n\t<bean id="fooBar" class="org.springframework.mylearntest.ioc.resourceloader.FooBar">\n\t\t<property name="resourceLoader" ref="resourceLoader"/>\n\t</bean>\n</beans>\n'})})]}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"Instance classes that implement ResourceLoaderAware or ApplicationContextAware interfaces"}),"\n"]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"resourceloader4ContextBoo.xml"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-XML",children:'<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n\n\t<bean id="fooBar" class="org.springframework.mylearntest.ioc.resourceloader.FooBarImplApplicationContextAware">\n\t</bean>\n</beans>\n'})})]}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"Resource Type Injection"}),"\n"]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"xmailer.xml"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-XML",children:'<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n\n\t<bean id="xMailer" class="org.springframework.mylearntest.ioc.resourceloader.XMailer">\n\t\t<property name="template" value="resourceloader/resources.default_template.vm"/>\n\t</bean>\n</beans>\n'})})]}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsx)(n.li,{children:"ApplicationContext's Resource Loading Behavior\nWhen ClassPathXmlApplicationContext is instantiated, even without specifying prefixes like classpath: or classpath*:, it will load bean definition configuration files from the classpath by default, while FileSystemXmlApplicationContext is somewhat similar. If we specify conf/appContext.xml as in the following code, it will try to load bean definition files from the file system"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"internationalization-support-i18n-messagesource",children:"Internationalization Support (i18n MessageSource)"}),"\n",(0,s.jsx)(n.p,{children:"Internationalization support provided by Java SE"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Locale"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Different Locales represent different countries and regions. Each country and region has corresponding abbreviation codes in Locale, including language codes and country codes, which are ISO standard codes. For example, Locale.CHINA represents China."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"ResourceBundle"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"ResourceBundle is used to save information specific to a certain Locale (can be String type information or any type of object). Usually ResourceBundle manages a set of information sequences, all information sequences have a unified basename, and then information for specific Locales can be distinguished by appending language or region codes after the basename. For example, we can use a set of properties files to save information for different countries and regions, and name the corresponding properties files as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"messages.properties\nmessages_zh.properties\nmessages_zh_CN.properties\nmessages_en.properties\nmessages_en_US.properties\n"})}),"\n",(0,s.jsx)(n.p,{children:"Among them, the messages part in the filename is called the basename of the resource that ResourceBundle will load, and resources for other languages or regions append Locale-specific codes based on the basename."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://s2.loli.net/2023/07/15/8Y4A7NIqHhxa6Qb.png",alt:""})}),"\n",(0,s.jsx)(n.p,{children:"If a business object needs internationalization information support, the simplest way is to let it implement the MessageSourceAware interface and then register it with the ApplicationContext container. However, this makes the business object too dependent on the ApplicationContext container, making the container quite intrusive. In fact, if a business object really needs to depend on MessageSource, it can directly declare the dependency through constructor injection or setter method injection."}),"\n",(0,s.jsx)(n.h2,{id:"container-internal-event-publishing",children:"Container Internal Event Publishing"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Custom Event Publishing\nProvide custom event types (define your own event object). To distinguish specific event types for specific scenarios, we need to provide our own event type definitions. The usual practice is to extend the java.util.EventObject class to implement custom event types."}),"\n"]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Define Event Type"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"package org.springframework.mylearntest.ioc.eventpublication.applicationevent;\n\nimport org.springframework.context.ApplicationEvent;\nimport org.springframework.mylearntest.ioc.eventpublication.event.MethodExecutionStatus;\n\npublic class MethodExecutionEvent extends ApplicationEvent {\n\tprivate static final long serialVersionUID = -71960369269303337L;\n\tprivate String methodName;\n\tprivate MethodExecutionStatus methodExecutionStatus;\n\n\tpublic MethodExecutionEvent(Object source) {\n\t\tsuper(source);\n\t}\n\t\n\tpublic MethodExecutionEvent(Object source, String methodName, MethodExecutionStatus methodExecutionStatus) {\n\t\tsuper(source);\n\t\tthis.methodName = methodName;\n\t\tthis.methodExecutionStatus = methodExecutionStatus;\n\t}\n\t\n\tpublic String getMethodName() {\n\t\treturn methodName;\n\t}\n\t\n\tpublic void setMethodName(String methodName) {\n\t\tthis.methodName = methodName;\n\t}\n\t\n\tpublic MethodExecutionStatus getMethodExecutionStatus() {\n\t\treturn methodExecutionStatus;\n\t}\n\t\n\tpublic void setMethodExecutionStatus(MethodExecutionStatus methodExecutionStatus) {\n\t\tthis.methodExecutionStatus = methodExecutionStatus;\n\t}\n}\n"})})]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Define Event Listener Interface"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"package org.springframework.mylearntest.ioc.eventpublication.event;\n\n\nimport java.util.EventListener;\n\n/**\n * Custom event listener\n */\npublic interface MethodExecutionEventListener extends EventListener {\n\t/**\n\t * Handle MethodExecutionEvent published when method starts executing\n\t */\n\tvoid onMethodBegin(MethodExecutionEvent evt);\n\t/**\n\t * Handle MethodExecutionEvent published when method execution is about to end\n\t */\n\tvoid onMethodEnd(MethodExecutionEvent evt);\n}\n\n"})})]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Custom Event Listener Implementation"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'package org.springframework.mylearntest.ioc.eventpublication.event;\n\n/**\n * Custom event listener implementation\n */\npublic class SimpleMethodExecutionEventListener implements MethodExecutionEventListener {\n\n\tpublic void onMethodBegin(MethodExecutionEvent evt) {\n\t\tString methodName = evt.getMethodName();\n\t\tSystem.out.println("start to execute the method[" + methodName + "].");\n\t}\n\n\tpublic void onMethodEnd(MethodExecutionEvent evt) {\n\t\tString methodName = evt.getMethodName();\n\t\tSystem.out.println("finished to execute the method[" + methodName + "].");\n\t}\n}\n'})})]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Define Event Status Enum and Event Publisher"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"package org.springframework.mylearntest.ioc.eventpublication.event;\n\npublic enum MethodExecutionStatus {\n\tBEGIN,END\n}\n"})})]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Event Publishing Class"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'package org.springframework.mylearntest.ioc.eventpublication.event;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MethodExecutionEventPublisher {\n\tprivate List<MethodExecutionEventListener> listeners = new ArrayList<>();\n\n\tpublic void methodToMonitor() {\n\t\tMethodExecutionEvent event2Publish = new MethodExecutionEvent(this, "methodToMonitor");\n\t\tpublishEvent(MethodExecutionStatus.BEGIN, event2Publish);\n\t\t// Execute actual method logic\n\t\t// ...\n\t\tpublishEvent(MethodExecutionStatus.END, event2Publish);\n\t}\n\n\t// To avoid registration or removal operations of event listeners during event processing affecting the process, we make a safe copy of the listener list at the time of event publishing\n\tprotected void publishEvent(MethodExecutionStatus status, MethodExecutionEvent methodExecutionEvent) {\n\t\tList<MethodExecutionEventListener> copyListeners = new ArrayList<>(listeners);\n\t\tfor (MethodExecutionEventListener listener : copyListeners) {\n\t\t\tif (MethodExecutionStatus.BEGIN.equals(status)) {\n\t\t\t\tlistener.onMethodBegin(methodExecutionEvent);\n\t\t\t} else {\n\t\t\t\tlistener.onMethodEnd(methodExecutionEvent);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void addMethodExecutionEventListener(MethodExecutionEventListener listener) {\n\t\tthis.listeners.add(listener);\n\t}\n\n\tpublic void removeListener(MethodExecutionEventListener listener) {\n\t\tthis.listeners.remove(listener);\n\t}\n\n\tpublic void removeAllListeners() {\n\t\tthis.listeners.clear();\n\t}\n\n}\n'})})]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Test Class"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"package org.springframework.mylearntest.ioc.eventpublication.event;\n\npublic class Test4Event {\n\tpublic static void main(String[] args) {\n\t\tMethodExecutionEventPublisher eventPublisher = new MethodExecutionEventPublisher();\n\t\teventPublisher.addMethodExecutionEventListener(new SimpleMethodExecutionEventListener());\n\t\teventPublisher.methodToMonitor();\n\t\teventPublisher.removeAllListeners();\n\t}\n}\n"})})]}),"\n",(0,s.jsx)(n.p,{children:"In the implementation, it should be noted that to avoid registration or removal operations of event listeners during event processing affecting the process, we make a safe copy of the listener list at the time of event publishing. Additionally, event publishing is executed sequentially, so to avoid affecting processing performance, the processing logic of event listeners should be as brief as possible."}),"\n",(0,s.jsx)("img",{src:"https://s2.loli.net/2023/07/15/Qmwxcpa4qDJGMYu.png"}),"\n",(0,s.jsx)(n.p,{children:"Spring's Container Internal Event Publishing Class Structure Analysis"}),"\n",(0,s.jsx)(n.p,{children:"Spring's ApplicationContext container internally allows publishing events in the form of org.springframework.context.ApplicationEvent. Bean definitions of org.springframework.context.ApplicationListener type registered in the container will be automatically recognized by the ApplicationContext container, and they are responsible for listening to all ApplicationEvent type events published within the container."}),"\n",(0,s.jsx)(n.p,{children:"ApplicationEvent: Spring container's custom event type, inheriting from java.util.EventObject. It is an abstract class that needs to provide corresponding subclasses according to different situations. By default, Spring provides three implementations."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"ContextClosedEvent: Event type published when ApplicationContext container is about to close."}),"\n",(0,s.jsx)(n.li,{children:"ContextRefreshedEvent: Event type published when ApplicationContext container is initialized or refreshed."}),"\n",(0,s.jsx)(n.li,{children:"RequestHandledEvent: Event published after web request processing, with a subclass ServletRequestHandledEvent providing Java EE Servlet-specific events."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"ApplicationListener: Custom event listener interface definition used within ApplicationContext container, inheriting from java.util.EventListener."}),"\n",(0,s.jsx)(n.p,{children:"ApplicationContext: When the container starts, it will automatically recognize and load EventListener type bean definitions. Once there are events published within the container, these EventListeners registered with the container will be notified."}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"MethodExecutionEventListener"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'package org.springframework.mylearntest.eventpublication.applicationevent;\n\n\nimport org.springframework.context.ApplicationEvent;\nimport org.springframework.context.ApplicationListener;\n\n@SuppressWarnings("rawtypes")\npublic class MethodExecutionEventListener implements ApplicationListener {\n    public void onApplicationEvent(ApplicationEvent evt) {\n        if (evt instanceof MethodExecutionEvent) {\n            // Execute processing logic\n        }\n    }\n}\n'})})]}),"\n",(0,s.jsx)(n.p,{children:"ApplicationContext: Remember the definition of ApplicationContext? Besides the previous ResourceLoader and MessageSource, the ApplicationContext interface definition also inherits the ApplicationEventPublisher interface, which provides the void publishEvent(ApplicationEvent event) method definition. It's not hard to see that the ApplicationContext container now plays the role of event publisher. The specific implementation classes of ApplicationContext container do not handle event publishing and event listener registration personally, but delegate these tasks to an interface called org.springframework.context.event.ApplicationEventMulticaster."}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"MethodExecutionEventPublisher"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'package org.springframework.mylearntest.eventpublication.applicationevent;\n\nimport org.springframework.context.ApplicationEventPublisher;\nimport org.springframework.context.ApplicationEventPublisherAware;\nimport org.springframework.mylearntest.eventpublication.event.MethodExecutionStatus;\n\npublic class MethodExecutionEventPublisher implements ApplicationEventPublisherAware {\n    private ApplicationEventPublisher eventPublisher;\n\n    public void methodToMonitor() {\n        MethodExecutionEvent beginEvt = new\n                MethodExecutionEvent(this, "methodToMonitor", MethodExecutionStatus.BEGIN);\n        this.eventPublisher.publishEvent(beginEvt);\n        // Execute actual method logic\n        // ...\n        MethodExecutionEvent endEvt = new\n                MethodExecutionEvent(this, "methodToMonitor", MethodExecutionStatus.END);\n        this.eventPublisher.publishEvent(endEvt);\n    }\n\n    public void setApplicationEventPublisher(ApplicationEventPublisher appCtx) {\n        this.eventPublisher = appCtx;\n    }\n}\n'})})]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"applicationevent.xml"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    <bean id="methodExecListener" class="org.springframework.mylearntest.eventpublication.applicationevent.MethodExecutionEventListener">\n    </bean>\n    <bean id="evtPublisher" class="org.springframework.mylearntest.eventpublication.applicationevent.MethodExecutionEventPublisher">\n    </bean>\n\n</beans>\n'})})]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Test4AppEvent"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'package org.springframework.mylearntest.eventpublication.applicationevent;\n\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class Test4AppEvent {\n    public static void main(String[] args) {\n        ApplicationContext context = new ClassPathXmlApplicationContext("eventpublication/applicationevent.xml");\n        MethodExecutionEventPublisher evtPublisher = (MethodExecutionEventPublisher) context.getBean("evtPublisher");\n        evtPublisher.methodToMonitor();\n    }\n}\n'})})]}),"\n",(0,s.jsx)(n.p,{children:"ApplicationEventMulticaster has an abstract implementation class\u2014org.springframework.context.event.AbstractApplicationEventMulticaster, which implements event listener management functionality. Event publishing functionality is delegated to its subclass org.springframework.context.event.SimpleApplicationEventMulticaster. It uses SyncTaskExecutor by default for event publishing. To avoid potential performance issues with this approach, we can provide other types of TaskExecutor implementation classes for it."}),"\n",(0,s.jsx)(n.p,{children:"When the container starts, it checks whether there is an ApplicationEventMulticaster object instance named applicationEventMulticaster in the container. If there is, it uses the provided implementation; if not, it initializes a SimpleApplicationEventMulticaster by default as the ApplicationEventMulticaster to be used."}),"\n",(0,s.jsx)("img",{src:"https://s2.loli.net/2023/07/15/TvPHprcI9eL4DSz.png"}),"\n",(0,s.jsx)(n.h2,{id:"ioc-related-annotations",children:"IoC Related Annotations"}),"\n",(0,s.jsx)(n.p,{children:"Looking at dependency injection related information, half is scattered in Java source code (@Autowired annotated information), and half still remains in XML configuration files, with many bean tags still existing.\nWhen using @Autowired annotation can find two or more object instances of the same type simultaneously, you can use @Qualifier to further qualify the conditions for dependency injection, specifying which specific id."}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"XML Method"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<beans>\n    <bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"/>\n    <bean id="newsProvider" class="..FXNewsProvider"/>\n    <bean id="djNewsListener" class="..DowJonesNewsListener"/>\n    <bean id="reutersNewsListner" class="..ReutersNewsListener"/>\n    <bean id="djNewsPersister" class="..DowJonesNewsPersister"/>\n</beans>\n'})})]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"@Qualifier on Properties"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public class FXNewsProvider {\n    @Autowired\n    @Qualifier("reutersNewsListner")// At this time inject id=reutersNewsListner\n    private IFXNewsListener newsListener;\n    @Autowired\n    private IFXNewsPersister newPersistener;\n    //...\n}\n'})})]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"@Qualifier Annotation on Parameters"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// @Qualifier annotation on parameters\npublic class FXNewsProvider{\n    // ...\n    @Autowired\n    public void setUp(@Qualifier("reutersNewsListner") IFXNewsListener newsListener,IFXNewsPersister newPersistener) {\n        this.newsListener = newsListener;\n        this.newPersistener = newPersistener;\n    }\n    // ...\n}\n'})})]}),"\n",(0,s.jsx)(n.p,{children:"@Resource is different from @Autowired. It follows the byName automatic binding behavior principle, which means the IoC container will search for instances in the container with beanName corresponding to the name specified by @Resource, and then inject the found object instance into the object annotated by @Resource."}),"\n",(0,s.jsx)(n.p,{children:"@PostConstruct and @PreDestroy are not for dependency injection. They are mainly used to annotate methods related to object lifecycle management, which is similar to Spring's InitializingBean and DisposableBean interfaces, as well as init-method and destroy-method in configuration items."}),"\n",(0,s.jsx)(n.p,{children:"Just like @Autowired needs AutowiredAnnotationBeanPostProcessor to bridge it with the IoC container, JSR250 annotations also need a BeanPostProcessor to help them realize their value. This BeanPostProcessor is org.springframework.context.annotation.CommonAnnotationBeanPostProcessor. Only by adding CommonAnnotationBeanPostProcessor to the container can JSR250 related annotations take effect."}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"XML Configuration"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<beans>\n    <bean class="org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"/>\n    <bean id="newsProvider" class="..FXNewsProvider"/>\n    <bean id="djNewsListener" class="..DowJonesNewsListener"/>\n    <bean id="djNewsPersister" class="..DowJonesNewsPersister"/>\n</beans>\n'})})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"<context:annotation-config>"})," not only helps us register AutowiredAnnotationBeanPostProcessor and CommonAnnotationBeanPostProcessor to the container, but also registers PersistenceAnnotationBeanPostProcessor and RequiredAnnotationBeanPostProcessor together, achieving four benefits at once!"]}),"\n",(0,s.jsx)(n.p,{children:"After annotating the relevant classes that make up the application with corresponding annotations, the classpath-scanning functionality can start scanning from a certain top-level package (base package). When it scans that a class is annotated with corresponding annotations, it will extract the relevant information of that class, build the corresponding BeanDefinition, and then register the built BeanDefinition to the container."}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"XML Configuration"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<beans xmlns="http://www.springframework.org/schema/beans"\nxmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\nxmlns:context="http://www.springframework.org/schema/context"\nxsi:schemaLocation="http://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans-2.5.xsd\nhttp://www.springframework.org/schema/context\nhttp://www.springframework.org/schema/context/spring-context-2.5.xsd">\n    <context:component-scan base-package="org.spring21"/>\n</beans>\n'})})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"References"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Book Title: Spring Revealed Author: Wang Fuqiang"}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);