"use strict";(self.webpackChunksummary=self.webpackChunksummary||[]).push([["7775"],{11841(e,r,n){n.r(r),n.d(r,{metadata:()=>o,default:()=>x,frontMatter:()=>s,contentTitle:()=>c,toc:()=>l,assets:()=>d});var o=JSON.parse('{"id":"background/Java/Spring/AOP/Weaving/weaving-programmatic","title":"Weaving in Spring AOP 1","description":"Please refer to [spring-framework](https://github.com/Halcyon666/spring-framework-modified/tree/main/spring-test) for code related to this article (from official source spring-test module)","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/background/Java/Spring/AOP/Weaving/weaving-programmatic.mdx","sourceDirName":"background/Java/Spring/AOP/Weaving","slug":"/background/Java/Spring/AOP/Weaving/weaving-programmatic","permalink":"/en/background/Java/Spring/AOP/Weaving/weaving-programmatic","draft":false,"unlisted":false,"editUrl":"https://github.com/Halcyon666/summary/edit/main/docs/background/Java/Spring/AOP/Weaving/weaving-programmatic.mdx","tags":[{"inline":true,"label":"algorithm","permalink":"/en/tags/algorithm"},{"inline":true,"label":"computer-science","permalink":"/en/tags/computer-science"},{"inline":true,"label":"data-structures","permalink":"/en/tags/data-structures"}],"version":"current","lastUpdatedBy":"halcyon666","lastUpdatedAt":1769299200000,"sidebarPosition":10,"frontMatter":{"id":"weaving-programmatic","title":"Weaving in Spring AOP 1","sidebar_label":"Weaving in Spring AOP 1","sidebar_position":10,"description":"Please refer to [spring-framework](https://github.com/Halcyon666/spring-framework-modified/tree/main/spring-test) for code related to this article (from official source spring-test module)","tags":["algorithm","computer-science","data-structures"],"last_update":{"date":"2026-01-25","author":"halcyon666"},"sources":["spring-core"]},"sidebar":"tutorialSidebar","previous":{"title":"Weaving in Spring AOP 2","permalink":"/en/background/Java/Spring/AOP/Weaving/weaving-autoproxy"},"next":{"title":"Overview of AspectJ style AOP","permalink":"/en/background/Java/Spring/AOP/AspectJ/aspectj-overview"}}'),t=n(62615),a=n(77545),i=n(4040);let s={id:"weaving-programmatic",title:"Weaving in Spring AOP 1",sidebar_label:"Weaving in Spring AOP 1",sidebar_position:10,description:"Please refer to [spring-framework](https://github.com/Halcyon666/spring-framework-modified/tree/main/spring-test) for code related to this article (from official source spring-test module)",tags:["algorithm","computer-science","data-structures"],last_update:{date:"2026-01-25",author:"halcyon666"},sources:["spring-core"]},c,d={},l=[{value:"Interface-based Proxy",id:"interface-based-proxy",level:2},{value:"Class-based Proxy",id:"class-based-proxy",level:2},{value:"Weaving of Introduction",id:"weaving-of-introduction",level:2},{value:"Essence of ProxyFactory",id:"essence-of-proxyfactory",level:2},{value:"Essence of ProxyFactoryBean",id:"essence-of-proxyfactorybean",level:2},{value:"Usage of ProxyFactoryBean",id:"usage-of-proxyfactorybean",level:2},{value:"ProxyFactoryBean Generating Proxy Object Case",id:"proxyfactorybean-generating-proxy-object-case",level:2}];function p(e){let r={a:"a",blockquote:"blockquote",code:"code",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components},{Details:n}=r;return n||function(e,r){throw Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(r.p,{children:["Please refer to ",(0,t.jsx)(r.a,{href:"https://github.com/Halcyon666/spring-framework-modified/tree/main/spring-test",children:"spring-framework"})," under ",(0,t.jsx)(r.code,{children:"org.springframework.mylearntest"})," package for code related to this article (from ",(0,t.jsx)(r.a,{href:"https://github.com/spring-projects/spring-framework.git",title:"official source",children:"official source"})," spring-test module)."]}),"\n",(0,t.jsxs)(r.p,{children:["AspectJ uses ",(0,t.jsx)(r.code,{children:"ajc"})," compiler as its weaver; JBoss AOP uses custom ",(0,t.jsx)(r.code,{children:"ClassLoader"})," as its weaver; while in Spring AOP, class ",(0,t.jsx)(r.code,{children:"org.springframework.aop.framework.ProxyFactory"})," is used as weaver."]}),"\n",(0,t.jsx)(r.p,{children:"Usage:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:["Pass in object to be woven\n",(0,t.jsx)(r.code,{children:"ProxyFactory weaver = new ProxyFactory(target);"})]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"Bind Advisor that will be applied to target object to weaver"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["If it is not an ",(0,t.jsx)(r.code,{children:"Introduction"})," Advice type, Proxy will construct corresponding Advisor for these Advices internally, expecting that ",(0,t.jsx)(r.code,{children:"Pointcut"})," used in constructing Advisor for them is ",(0,t.jsx)(r.code,{children:"Pointcut.TRUE"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:["If it is ",(0,t.jsx)(r.code,{children:"Introduction"})," type, it will be distinguished according to specific type of ",(0,t.jsx)(r.code,{children:"Introduction"}),"; if it is a subclass implementation of ",(0,t.jsx)(r.code,{children:"Introduction"}),", framework will construct a ",(0,t.jsx)(r.code,{children:"DefaultIntroductionAdvisor"})," for it internally; if it is a subclass implementation of ",(0,t.jsx)(r.code,{children:"DynamicIntroductionAdvice"}),", framework will throw ",(0,t.jsx)(r.code,{children:"AOPConfigException"})," exception (because necessary target object information cannot be obtained from ",(0,t.jsx)(r.code,{children:"DynamicIntroductionAdvice"}),")"]}),"\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.code,{children:"weaver.addAdvisor(advisor);"})}),"\n"]}),"\n",(0,t.jsxs)(r.ol,{start:"3",children:["\n",(0,t.jsxs)(r.li,{children:["Get proxy object\n",(0,t.jsx)(r.code,{children:"Object proxyObject =  weaver.getProxy();"})]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"interface-based-proxy",children:"Interface-based Proxy"}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:"Test4ProxyFactory"}),(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package org.springframework.mylearntest.aop.weaver;\n\nimport org.springframework.aop.framework.ProxyFactory;\nimport org.springframework.aop.support.NameMatchMethodPointcutAdvisor;\n\nimport java.util.Date;\n\n/**\n * @Author: whalefall\n * @Date: 2020/7/15 22:53\n */\n\n@SuppressWarnings({"rawtypes", "Deprecated"})\npublic class Test4ProxyFactory {\n    public static void main(String[] args) {\n        /*// 1. Pass in object to be woven\n        ProxyFactory weaver = new ProxyFactory(new Tester());\n        // weaver.setTarget(new Tester());\n\n        // 2. Bind Advisor that will be applied to target object to weaver\n        ApplicationContext context = new ClassPathXmlApplicationContext("advisor/defaultadvisor/defaultadvisor.xml");\n        Advisor advisor = (Advisor) context.getBean("advisor");\n        weaver.addAdvisor(advisor);\n\n        Object proxyObject =  weaver.getProxy();\n        System.out.println(proxyObject.getClass());\n        // out: class org.springframework.mylearntest.aop.advice.perinstance.Tester$$EnhancerBySpringCGLIB$$8e739b5b\n        */\n\n        // Usage where target class implements interface\n        // As long as optimize and proxyTargetClass of ProxyFactory are not set to true\n        // ProxyFactory will proxy based on interface\n        MockTask task = new MockTask();\n        ProxyFactory weaver = new ProxyFactory(task);\n        // weaver.setInterfaces(new Class[]{ITask.class});\n        NameMatchMethodPointcutAdvisor advisor = new NameMatchMethodPointcutAdvisor();\n        advisor.setMappedNames("execute");\n        advisor.setAdvice(new PerformanceMethodInterceptor());\n        weaver.addAdvisor(advisor);\n        ITask proxyObj = (ITask)weaver.getProxy();\n        // com.sun.proxy.$Proxy0\n        // System.out.println(proxyObj.getClass());\n        // Can only force cast to interface type, cannot cast to implementation class type, otherwise ClassCastException will be thrown\n        // ITask proxyObj = (MockTask)weaver.getProxy();\n        proxyObj.execute(new Date());\n\n    }\n}\n'})})]}),"\n",(0,t.jsx)(r.h2,{id:"class-based-proxy",children:"Class-based Proxy"}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:"TestCGLib"}),(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package org.springframework.mylearntest.aop.weaver.baseonclass;\n\nimport org.springframework.aop.framework.ProxyFactory;\nimport org.springframework.aop.support.NameMatchMethodPointcutAdvisor;\nimport org.springframework.mylearntest.aop.advice.perclass.PerformanceMethodInterceptor;\n\n/**\n * @Author: whalefall\n * @Date: 2020/7/17 23:31\n */\npublic class Test4CGLib {\n    public static void main(String[] args) {\n        ProxyFactory weaver = new ProxyFactory(new Executable());\n        NameMatchMethodPointcutAdvisor advisor = new NameMatchMethodPointcutAdvisor();\n\n        advisor.addMethodName("execute");\n        advisor.setAdvice(new PerformanceMethodInterceptor());\n        weaver.addAdvisor(advisor);\n\n        Executable proxyObject = (Executable)weaver.getProxy();\n        proxyObject.execute();\n        // org.springframework.mylearntest.aop.weaver.baseonclass.Executable$$EnhancerBySpringCGLIB$$37e40619\n        System.out.println("proxyObject class: " + proxyObject.getClass());\n    }\n}\n'})})]}),"\n",(0,t.jsxs)(r.p,{children:["If target class does not implement any interface, regardless of what ",(0,t.jsx)(r.code,{children:"proxyTargetClass"})," attribute is, ",(0,t.jsx)(r.code,{children:"ProxyFactoy"})," will use class-based proxy."]}),"\n",(0,t.jsxs)(r.p,{children:["If ",(0,t.jsx)(r.code,{children:"proxyTargetClass"})," attribute of ",(0,t.jsx)(r.code,{children:"ProxyFactoy"})," is set to true, ",(0,t.jsx)(r.code,{children:"ProxyFactoy"})," will use class-based proxy."]}),"\n",(0,t.jsxs)(r.p,{children:["If ",(0,t.jsx)(r.code,{children:"optimize"})," attribute of ",(0,t.jsx)(r.code,{children:"ProxyFactoy"})," is set to true, ",(0,t.jsx)(r.code,{children:"ProxyFactory"})," will use class-based proxy."]}),"\n",(0,t.jsx)(r.h2,{id:"weaving-of-introduction",children:"Weaving of Introduction"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"Introduction"})," can add new behaviors to existing object types, it can only be applied to object-level interception, not method-level interception of usual ",(0,t.jsx)(r.code,{children:"Advice"}),", so in process of ",(0,t.jsx)(r.code,{children:"Introduction"})," weaving, there is no need to specify ",(0,t.jsx)(r.code,{children:"Pointcut"}),", but only need to specify target interface type."]}),"\n",(0,t.jsxs)(r.p,{children:["Spring's ",(0,t.jsx)(r.code,{children:"Introduction"})," support can only add new behaviors to current object by defining interfaces. So, we need to specify type of newly woven interface at time of weaving."]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:"Test4Introduction"}),(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package org.springframework.mylearntest.aop.weaver.introduction;\n\nimport org.springframework.aop.framework.ProxyFactory;\nimport org.springframework.mylearntest.aop.advice.perinstance.Developer;\nimport org.springframework.mylearntest.aop.advice.perinstance.IDeveloper;\nimport org.springframework.mylearntest.aop.advice.perinstance.ITester;\nimport org.springframework.mylearntest.aop.advice.perinstance.TesterFeatureIntroductionInterceptor;\n\n/**\n * @Author: whalefall\n * @Date: 2020/7/19 0:02\n */\n\n@SuppressWarnings("rawtypes")\npublic class Test4Introduction {\n    public static void main(String[] args) {\n        ProxyFactory weaver = new ProxyFactory(new Developer());\n        weaver.setInterfaces(new Class[]{IDeveloper.class, ITester.class});\n        TesterFeatureIntroductionInterceptor advice = new TesterFeatureIntroductionInterceptor();\n        weaver.addAdvice(advice);\n        // DefaultIntroductionAdvisor advisor = new DefaultIntroductionAdvisor(advice,advice);\n        // weaver.addAdvisor(advisor);\n\n        Object proxy = weaver.getProxy();\n        ((ITester)proxy).testSoftware();\n        ((IDeveloper)proxy).developSoftware();\n        System.out.println("proxy = " + proxy);\n\n    }\n}\n'})})]}),"\n",(0,t.jsx)(r.h2,{id:"essence-of-proxyfactory",children:"Essence of ProxyFactory"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.img,{src:"https://s2.loli.net/2023/07/15/PpJEQOIGl7dKtj3.png",alt:""})}),"\n",(0,t.jsxs)(r.p,{children:["Spring AOP framework uses ",(0,t.jsx)(r.code,{children:"AopProxy"})," to moderately abstract proxy implementation mechanisms used, mainly having two ",(0,t.jsx)(r.code,{children:"AopProxy"})," implementations for JDK dynamic proxy and CGLIB mechanisms, namely ",(0,t.jsx)(r.code,{children:"Cglib2AopProxy"})," and ",(0,t.jsx)(r.code,{children:"JdkDynamicAopProxy"}),". Dynamic proxy needs to provide call interception via ",(0,t.jsx)(r.code,{children:"InvocationHandler"}),", so ",(0,t.jsx)(r.code,{children:"JdkDynamicAopProxy"})," also implements ",(0,t.jsx)(r.code,{children:"InvocationHandler"})," interface. Adopting abstract factory pattern, proceeding through ",(0,t.jsx)(r.code,{children:"org.springframework.aop.framework.AopProxyFactory"}),"."]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:"AopProxyFactory"}),(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"public interface AopProxyFactory {\n    AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException;\n}\n"})})]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"AopProxyFactory"})," decides what type of ",(0,t.jsx)(r.code,{children:"AopProxy"})," to generate based on relevant information provided by passed ",(0,t.jsx)(r.code,{children:"AdvisedSupport"})," instance. Specific work is completed by concrete implementation classes of ",(0,t.jsx)(r.code,{children:"AopProxyFactory"}),". I.e., ",(0,t.jsx)(r.code,{children:"org.springframework.aop.framework.DefaultAopProxyFactory"}),"."]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:"DefaultAopProxyFactory"}),(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package org.springframework.aop.framework;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Proxy;\n\nimport org.springframework.aop.SpringProxy;\n\n@SuppressWarnings("serial")\npublic class DefaultAopProxyFactory implements AopProxyFactory, Serializable {\n\n    @Override\n    public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {\n        // If isOptimize or isProxyTargetClass method of passed AdvisedSupport instance returns true,\n        // Or target object does not implement any interface, then use CGLIB to generate proxy object, otherwise use dynamic proxy.\n        if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {\n            Class<?> targetClass = config.getTargetClass();\n            if (targetClass == null) {\n                throw new AopConfigException("TargetSource cannot determine target class: " +\n                        "Either an interface or a target is required for proxy creation.");\n            }\n            if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {\n                return new JdkDynamicAopProxy(config);\n            }\n            return new ObjenesisCglibAopProxy(config);\n        }\n        else {\n            return new JdkDynamicAopProxy(config);\n        }\n    }\n\n    private boolean hasNoUserSuppliedProxyInterfaces(AdvisedSupport config) {\n        Class<?>[] ifcs = config.getProxiedInterfaces();\n        return (ifcs.length == 0 || (ifcs.length == 1 && SpringProxy.class.isAssignableFrom(ifcs[0])));\n    }\n\n}\n'})})]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.img,{src:"https://s2.loli.net/2023/07/15/pW1gjoys6k47dvm.png",alt:""})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"AdvisedSupport"})," is a carrier of information needed to generate proxy object."]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["One class headed by ",(0,t.jsx)(r.code,{children:"org.springframework.aop.framework.ProxyConfig"}),", records control information for generating proxy object;"]}),"\n",(0,t.jsxs)(r.li,{children:["One class headed by ",(0,t.jsx)(r.code,{children:"org.springframework.aop.framework.Advised"}),", carries necessary information needed to generate proxy object, such as related target class, Advice, Advisor etc."]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"ProxyConfig"})," is a simple JavaBean, defining five boolean attributes, controlling what measures should be taken when generating proxy object respectively."]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"ProxyTargetClass"}),": If this attribute is set to true, ",(0,t.jsx)(r.code,{children:"ProxyFactory"})," will use CGLIB to proxy target object. Default value is false."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"optimize"}),": This attribute is mainly used to inform whether proxy object needs to take further optimization measures. If proxy object is generated, even if corresponding ",(0,t.jsx)(r.code,{children:"Advice"})," is added or removed for it, proxy object can ignore this change. If this attribute is set to true, ",(0,t.jsx)(r.code,{children:"ProxyFactory"})," will use CGLIB to proxy target object. Default value is false."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"opaque"}),": This attribute is used to control whether generated proxy object can be forced directly to cast to ",(0,t.jsx)(r.code,{children:"Advised"}),", default value is false, meaning any generated proxy object can be forced cast to ",(0,t.jsx)(r.code,{children:"Advised"}),", we can query some states of proxy object via ",(0,t.jsx)(r.code,{children:"Advised"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"exposeProxy"}),": Setting ",(0,t.jsx)(r.code,{children:"exposeProxy"})," allows Spring AOP framework to bind current proxy object to ",(0,t.jsx)(r.code,{children:"ThreadLocal"})," when generating proxy object. If target object needs to access current proxy object, it can get proxy object via ",(0,t.jsx)(r.code,{children:"AopContext.currentProxy()"}),". For performance considerations, this attribute defaults to false."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"frozen"}),": If ",(0,t.jsx)(r.code,{children:"frozen"})," is set to true, once various information configurations for proxy object are completed, changes are not allowed. For example, ",(0,t.jsx)(r.code,{children:"ProxyFactory"})," is set up, and ",(0,t.jsx)(r.code,{children:"frozen"})," is true, then no changes can be made to ",(0,t.jsx)(r.code,{children:"Advice"}),", this can optimize performance of proxy object, defaults to false."]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["To generate proxy object, information provided by ",(0,t.jsx)(r.code,{children:"ProxyConfig"})," alone is not enough, we also need some specific information for generating proxy object, for example, for which target classes to generate proxy object, what kind of cross-cutting logic to add to proxy object etc., this information can be set via ",(0,t.jsx)(r.code,{children:"org.springframework.aop.framework.Advised"}),". By default, proxy objects returned by Spring AOP framework can all be forced cast to ",(0,t.jsx)(r.code,{children:"Advised"}),", to query related information of proxy object."]}),"\n",(0,t.jsxs)(r.p,{children:["We can use ",(0,t.jsx)(r.code,{children:"Advised"})," interface to access all ",(0,t.jsx)(r.code,{children:"Advisor"})," held by corresponding proxy object, perform actions like adding ",(0,t.jsx)(r.code,{children:"Advisor"}),", removing ",(0,t.jsx)(r.code,{children:"Advisor"})," etc. Even if proxy object has been generated, it can also be operated, operate ",(0,t.jsx)(r.code,{children:"Advised"})," directly, more often used in testing scenarios, can help us check whether generated proxy object is as expected."]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.img,{src:"https://s2.loli.net/2023/07/15/hHNUgpVWqDFlZIw.png",alt:""})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"ProxyFactory"})," combines ",(0,t.jsx)(r.code,{children:"AopProxy"})," and ",(0,t.jsx)(r.code,{children:"AdvisedSupport"})," in one, can set relevant information needed to generate proxy object via ",(0,t.jsx)(r.code,{children:"AdvisedSupport"}),", can generate proxy object via ",(0,t.jsx)(r.code,{children:"AopProxy"}),". To reuse relevant logic, Spring AOP framework extracted some common logic to ",(0,t.jsx)(r.code,{children:"org.springframework.aop.framework.ProxyCreatorSupport"})," during implementation, it inherits ",(0,t.jsx)(r.code,{children:"AdvisedSupport"}),", so it can have ability to set relevant information needed to generate proxy object."]}),"\n",(0,t.jsxs)(r.p,{children:["In order to simplify work of generating different types of ",(0,t.jsx)(r.code,{children:"AopProxy"}),", ",(0,t.jsx)(r.code,{children:"ProxyCreatorSupport"})," internally holds an ",(0,t.jsx)(r.code,{children:"AopProxyFactory"})," instance, default uses ",(0,t.jsx)(r.code,{children:"DefaultAopProxyFactory"}),"."]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.img,{src:"https://s2.loli.net/2023/07/15/TYd9iNmCvOAUcjt.png",alt:""})}),"\n",(0,t.jsx)(r.h2,{id:"essence-of-proxyfactorybean",children:"Essence of ProxyFactoryBean"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"ProxyFactoryBean"})," is essentially a ",(0,t.jsx)(r.code,{children:"FactoryBean"})," used to produce Proxy. Role of ",(0,t.jsx)(r.code,{children:"FactoryBean"}),":"]}),"\n",(0,t.jsxs)(r.p,{children:["If an object holds a reference to a ",(0,t.jsx)(r.code,{children:"FactoryBean"}),", what it gets is not ",(0,t.jsx)(r.code,{children:"FactoryBean"})," itself, but object returned by ",(0,t.jsx)(r.code,{children:"FactoryBean"}),"'s ",(0,t.jsx)(r.code,{children:"getObject()"})," method. So, if an object in container depends on ",(0,t.jsx)(r.code,{children:"ProxyFactoryBean"}),", then it will use proxy object returned by ",(0,t.jsx)(r.code,{children:"ProxyFactoryBean"}),"'s ",(0,t.jsx)(r.code,{children:"getObject()"})," method."]}),"\n",(0,t.jsxs)(r.p,{children:["To let ",(0,t.jsx)(r.code,{children:"ProxyFactoryBean"}),"'s ",(0,t.jsx)(r.code,{children:"getObject()"})," method return proxy object of corresponding target object is actually very simple. Because ",(0,t.jsx)(r.code,{children:"ProxyFactoryBean"})," inherits common parent class ",(0,t.jsx)(r.code,{children:"ProxyCreatorSupport"})," of ",(0,t.jsx)(r.code,{children:"ProxyFactory"}),", and ",(0,t.jsx)(r.code,{children:"ProxyCreatorSupport"})," basically has completed all things to be done (setting target object, configuring other parts, generating corresponding ",(0,t.jsx)(r.code,{children:"AopProxy"})," etc.). We only need to get proxy object via parent class's ",(0,t.jsx)(r.code,{children:"createAopProxy()"})," in ",(0,t.jsx)(r.code,{children:"ProxyFactoryBean"}),"'s ",(0,t.jsx)(r.code,{children:"getObject()"})," method, then ",(0,t.jsx)(r.code,{children:"return AopProxy.getObject()"}),"."]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:"getObject()"}),(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'public Object getObject() throws BeansException {\n        initializeAdvisorChain();\n        if (isSingleton()) {\n            return getSingletonInstance();\n        }\n        else {\n            if (this.targetName == null) {\n                logger.info("Using non-singleton proxies with singleton targets is often undesirable. " +\n                        "Enable prototype proxies by setting the \'targetName\' property.");\n            }\n            return newPrototypeInstance();\n        }\n    }\n'})})]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"ProxyBean"})," definition requires indicating whether returned object is returned with singleton scope or prototype scope. Different proxy objects are returned for these two cases to satisfy semantics of ",(0,t.jsx)(r.code,{children:"FactoryBean"}),"'s ",(0,t.jsx)(r.code,{children:"isSingleton()"})," method."]}),"\n",(0,t.jsxs)(r.p,{children:["If ",(0,t.jsx)(r.code,{children:"singleton"})," attribute of ",(0,t.jsx)(r.code,{children:"ProxyFactoryBean"})," is set to true, then after ",(0,t.jsx)(r.code,{children:"ProxyFactoryBean"})," generates proxy object for first time, it will cache generated proxy object via internal instance variable ",(0,t.jsx)(r.code,{children:"singletonInstance"})," (Object type). All subsequent requests return this cached instance, thus satisfying singleton semantics. Conversely, if ",(0,t.jsx)(r.code,{children:"singleton"})," attribute of ",(0,t.jsx)(r.code,{children:"ProxyFactoryBean"})," is set to false, then ",(0,t.jsx)(r.code,{children:"ProxyFactoryBean"})," will re-check all settings every time, and prepare a new set of environment for current call, then return a new proxy object according to latest environment data. Therefore, if ",(0,t.jsx)(r.code,{children:"singleton"})," attribute is false, there is loss in performance of generating proxy object."]}),"\n",(0,t.jsx)(r.h2,{id:"usage-of-proxyfactorybean",children:"Usage of ProxyFactoryBean"}),"\n",(0,t.jsxs)(r.p,{children:["Like ",(0,t.jsx)(r.code,{children:"ProxyFactory"}),", via ",(0,t.jsx)(r.code,{children:"ProxyFactoryBean"}),", we can specify whether to use interface-based proxy or class-based proxy way when generating proxy object for target object, and, because they all inherit from same parent class, most setting items are same. ",(0,t.jsx)(r.code,{children:"ProxyFactoryBean"})," adds its own unique ones besides inheriting all configuration attributes of ",(0,t.jsx)(r.code,{children:"ProxyCreatorSupport"}),":"]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"proxyInterfaces"}),": If we want to use interface-based proxy way, then we need to configure corresponding interface types via this attribute, pass interface information of configuration element via ",(0,t.jsx)(r.code,{children:"Collection"})," object. ",(0,t.jsx)(r.code,{children:"ProxyFactoryBean"})," has an ",(0,t.jsx)(r.code,{children:"autodetectInterfaces"})," attribute, this attribute defaults to true, if interface type to be proxied is not explicitly specified, ",(0,t.jsx)(r.code,{children:"ProxyFactoryBean"})," will automatically detect interface types implemented by target object and perform proxy."]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"interceptorNames"}),": Via this attribute, we can specify multiple ",(0,t.jsx)(r.code,{children:"Advice"}),", interceptors and ",(0,t.jsx)(r.code,{children:"Advisor"})," to be woven into target object, instead of adding ",(0,t.jsx)(r.code,{children:"Advice"})," or ",(0,t.jsx)(r.code,{children:"addAdvisor"})," method of ",(0,t.jsx)(r.code,{children:"ProxyFactory"}),", usually we will use configuration element ",(0,t.jsx)(r.code,{children:"<list>"})," to add needed interceptor names."]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["If target object is not set, then can place Bean definition name of object at position of last element of ",(0,t.jsx)(r.code,{children:"interceptorNames"}),". It is recommended to define target object directly."]}),"\n",(0,t.jsxs)(r.li,{children:["By adding * wildcard after specified ",(0,t.jsx)(r.code,{children:"interceptorNames"})," element name, can let ",(0,t.jsx)(r.code,{children:"ProxyFactoryBean"})," search all ",(0,t.jsx)(r.code,{children:"Advisor"})," matching condition in container and apply to target object."]}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"Example using wildcard"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-xml",children:'<beans>\n    <bean id="proxy" class="org.springframework.aop.framework.ProxyFactoryBean">\n        <property name="target" ref="..."/>\n        <property name="interceptorNames">\n            <list>\n                <value>global*</value>\n            </list>\n        </property>\n    </bean>\n\n    <bean id="global_debug" class="org.springframework.aop.interceptor.DebugInterceptor"/>\n    <bean id="global_performance" class="org.springframework.aop.interceptor.PerformanceMonitorInterceptor">\n</beans>\n'})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"singleton"}),": ",(0,t.jsx)(r.code,{children:"ProxyFactoryBean"})," is essentially a ",(0,t.jsx)(r.code,{children:"FactoryBean"}),", so we can specify whether ",(0,t.jsx)(r.code,{children:"getObject"})," call returns same proxy object or new one via ",(0,t.jsx)(r.code,{children:"singleton"})," attribute."]}),"\n",(0,t.jsx)(r.h2,{id:"proxyfactorybean-generating-proxy-object-case",children:"ProxyFactoryBean Generating Proxy Object Case"}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:"Configuration File"}),(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-xml",children:'<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context-2.5.xsd">\n\n    \x3c!--    Bean definition of target object--\x3e\n    <bean id="task"\n          class="org.springframework.mylearntest.aop.weaver.baseoninterface.MockTask" scope="prototype"/>\n\n    \x3c!--    ProxyFactoryBean definition--\x3e\n    <bean id="introducedTask" class="org.springframework.aop.framework.ProxyFactoryBean" scope="prototype">\n        <property name="targetName">\n            <value>task</value>\n        </property>\n        <property name="proxyInterfaces">\n            <list>\n                <value>org.springframework.mylearntest.aop.weaver.baseoninterface.ITask</value>\n                <value>org.springframework.mylearntest.aop.weaver.proxyfactorybean.ICounter</value>\n            </list>\n        </property>\n        <property name="interceptorNames">\n            <list>\n                <value>introductionInterceptor</value>\n            </list>\n        </property>\n    </bean>\n\n    \x3c!--    introductionInterceptor definition--\x3e\n    <bean id="introductionInterceptor"\n          class="org.springframework.aop.support.DelegatingIntroductionInterceptor" scope="prototype">\n        <constructor-arg>\n            <bean class="org.springframework.mylearntest.aop.weaver.proxyfactorybean.CounterImpl"/>\n        </constructor-arg>\n    </bean>\n\n</beans>\n'})})]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:"ICounter"}),(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"package org.springframework.mylearntest.aop.weaver.proxyfactorybean;\n\n/**\n * @Author: whalefall\n * @Date: 2020/7/22 23:34\n */\npublic interface ICounter {\n    void resetCounter();\n    int getCounter();\n}\n"})})]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:"CounterImpl"}),(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"package org.springframework.mylearntest.aop.weaver.proxyfactorybean;\n\n/**\n * @Author: whalefall\n * @Date: 2020/7/22 23:35\n */\npublic class CounterImpl implements ICounter{\n    private int counter;\n\n    @Override\n    public void resetCounter() {\n        counter = 0;\n    }\n\n    @Override\n    public int getCounter() {\n        counter ++;\n        return counter;\n    }\n}\n"})})]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:"TestProxyFactoryBean"}),(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package org.springframework.mylearntest.aop.weaver.proxyfactorybean;\n\nimport org.springframework.aop.support.DelegatingIntroductionInterceptor;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\n/**\n * @Author: whalefall\n * @Date: 2020/7/22 23:51\n * @see DelegatingIntroductionInterceptor\n */\npublic class Test4ProxyFactoryBean {\n    public static void main(String[] args) {\n        ApplicationContext context = new ClassPathXmlApplicationContext("proxyfactorybean\\\\proxyfactorybean.xml");\n        Object proxy1 = context.getBean("introducedTask");\n        Object proxy2 = context.getBean("introducedTask");\n\n        System.out.println(((ICounter)proxy1).getCounter());//1\n        System.out.println(((ICounter)proxy1).getCounter());//2\n        System.out.println(((ICounter)proxy2).getCounter());//1\n    }\n}\n'})})]}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsx)(r.p,{children:"References"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsx)(r.li,{children:"Book Name: Spring Unveiled Author: Wang Fuqiang"}),"\n"]}),"\n"]}),"\n","\n",(0,t.jsx)(i.A,{})]})}function x(e={}){let{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}}}]);