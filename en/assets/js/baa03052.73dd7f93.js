"use strict";(self.webpackChunksummary=self.webpackChunksummary||[]).push([[4291],{1003:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"Java/JavaBase/lambda","title":"Lambda Usage","description":"Java 8 Functional Programming","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/01-Java/01-JavaBase/lambda.mdx","sourceDirName":"01-Java/01-JavaBase","slug":"/Java/JavaBase/lambda","permalink":"/summary/en/Java/JavaBase/lambda","draft":false,"unlisted":false,"editUrl":"https://github.com/Halcyon666/summary/edit/main/i18n/en/docusaurus-plugin-content-docs/current/01-Java/01-JavaBase/lambda.mdx","tags":[],"version":"current","lastUpdatedAt":1758292313000,"sidebarPosition":1,"frontMatter":{"title":"Lambda Usage","sidebar_label":"Lambda Usage","sidebar_position":1},"sidebar":"tutorialSidebar","next":{"title":"APT Usage","permalink":"/summary/en/Java/JavaBase/annotation processor"}}');var r=a(5813),i=a(3546);const s={title:"Lambda Usage",sidebar_label:"Lambda Usage",sidebar_position:1},c=void 0,l={},o=[{value:"Java 8 Functional Programming",id:"java-8-functional-programming",level:2},{value:"Refactoring Legacy Code",id:"refactoring-legacy-code",level:3},{value:"Function Method Parameter Overloading",id:"function-method-parameter-overloading",level:3},{value:"Interface Multiple Inheritance",id:"interface-multiple-inheritance",level:3},{value:"Sub-collector <code>groupingBy</code>",id:"sub-collector-groupingby",level:3},{value:"Refactoring Domain Methods",id:"refactoring-domain-methods",level:3},{value:"Tips",id:"tips",level:3}];function d(e){const n={blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"java-8-functional-programming",children:"Java 8 Functional Programming"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"NOTES: All content is excerpted from Java 8 Functional Programming"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"refactoring-legacy-code",children:"Refactoring Legacy Code"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public Set<String> findLongTracks(List<Album> albums) {\n    Set<String> trackNames=new HashSet<>();\n    for(Album album : albums) {\n        for (Track track : album.getTrackList()) {\n            if (track.getLength() > 60) {\n                String name=track.getName();\n                trackNames.add(name);\n            }\n        }\n    }\n    return trackNames;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Refactoring 1: Change ",(0,r.jsx)(n.code,{children:"for"})," to ",(0,r.jsx)(n.code,{children:"forEach"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public Set<String> findLongTracks(List<Album> albums) {\n    Set<String> trackNames=new HashSet<>();\n    albums.stream()\n        .forEach(album-> {\n            album.getTracks()\n                .forEach(track-> {\n                    if (track.getLength() > 60) {\n                        String name=track.getName();\n                        trackNames.add(name);\n                    }\n                });\n        });\n    return trackNames;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Refactoring 2: Change ",(0,r.jsx)(n.code,{children:"if"})," to ",(0,r.jsx)(n.code,{children:"filter"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public Set<String> findLongTracks(List<Album> albums) {\n    Set<String> trackNames=new HashSet<>();\n    albums.stream()\n        .forEach(album-> {\n            album.getTracks()\n                .filter(track-> track.getLength() > 60)\n                .map(track-> track.getName())\n                .forEach(name-> trackNames.add(name));\n        });\n    return trackNames;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Refactoring 3: Change outermost ",(0,r.jsx)(n.code,{children:"forEach"})," to ",(0,r.jsx)(n.code,{children:"flatMap"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public Set<String> findLongTracks(List<Album> albums) {\n    Set<String> trackNames=new HashSet<>();\n    albums.stream()\n        .flatMap(album-> album.getTracks())\n        .filter(track-> track.getLength() > 60)\n        .map(track-> track.getName())\n        .forEach(name-> trackNames.add(name));\n    return trackNames;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Refactoring 4: Change ",(0,r.jsx)(n.code,{children:"forEach"})," element addition to ",(0,r.jsx)(n.code,{children:"collect"})," for collection"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public Set<String> findLongTracks(List<Album> albums) {\n    return albums.stream()\n        .flatMap(album-> album.getTracks())\n        .filter(track-> track.getLength() > 60)\n        .map(track-> track.getName())\n        .collect(toSet());\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"function-method-parameter-overloading",children:"Function Method Parameter Overloading"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'overloadedMethod((x, y)-> x+y);\n\nprivate interface IntegerBiFunction extends BinaryOperator<Integer> {\n}\nprivate void overloadedMethod(BinaryOperator<Integer> Lambda) {\n    System.out.print("BinaryOperator");\n}\nprivate void overloadedMethod(IntegerBiFunction Lambda) {\n    System.out.print("IntegerBinaryOperator");\n}\n'})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["These methods accept ",(0,r.jsx)(n.code,{children:"BinaryOperator"})," and a subclass of that interface as parameters respectively. When calling these methods, the type of Lambda expression that Java infers is exactly the type of the most specific functional interface. For example, the example above outputs ",(0,r.jsx)(n.code,{children:"IntegerBinaryOperator"})," when choosing between the two methods."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"General Principles"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"If there is only one possible target type, it is inferred from the parameter types in the corresponding functional interface;"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"If there are multiple possible target types, it is inferred from the most specific type;"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"If there are multiple possible target types and the most specific type is unclear, manual type specification is required."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"interface-multiple-inheritance",children:"Interface Multiple Inheritance"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public interface Jukebox {\n    public default String rock() {\n        return "... all over the world! ";\n    }\n}\n\npublic interface Carriage {\n    public default String rock() {\n        return "... from side to side";\n    }\n}\n\npublic class MusicalCarriage implements Carriage, Jukebox {\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"javac"})," is not clear which interface method should be inherited, so the compiler reports an error: class Musical Carriage inherits unrelated defaults for rock() from types Carriage and Jukebox."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public class MusicalCarriage\n    implements Carriage, Jukebox {\n    @Override\n    public String rock() {\n        return Carriage.super.rock();\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"General Principles"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Classes win over interfaces. If there are method bodies or abstract method declarations in the inheritance chain, then methods defined in interfaces can be ignored."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Subclasses win over parent classes. If an interface inherits from another interface, and both interfaces define a default method, then the method defined in the subclass wins."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"There is no rule three. If the above two rules don't apply, the subclass must either implement the method or declare the method as abstract."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.ol,{start:"5",children:["\n",(0,r.jsxs)(n.li,{children:["For example, when using parallel streams, the ",(0,r.jsx)(n.code,{children:"forEach"})," method cannot guarantee that elements are processed in order. If you need to guarantee order processing, you should use the ",(0,r.jsx)(n.code,{children:"forEachOrdered"})," method."]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"sub-collector-groupingby",children:["Sub-collector ",(0,r.jsx)(n.code,{children:"groupingBy"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public Map<Artist, List<String>> nameOfAlbums(Stream<Album> albums) {\n    return albums.collect(groupingBy(Album::getMainMusician, mapping(Album::getName, toList())));\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["mapping allows performing map-like operations on the collector's container. But you need to specify what kind of collection class to use to store the results, such as ",(0,r.jsx)(n.code,{children:"toList"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"refactoring-domain-methods",children:"Refactoring Domain Methods"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public long countFeature(ToLongFunction<Album> function) {\n    return albums.stream()\n        .mapToLong(function)\n        .sum();\n}\npublic long countTracks() {\n    return countFeature(album-> album.getTracks().count());\n}\npublic long countRunningTime() {\n    return countFeature(album-> album.getTracks()\n                        .mapToLong(track-> track.getLength())\n                        .sum());\n}\npublic long countMusicians() {\n    return countFeature(album-> album.getMusicians().count());\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"tips",children:"Tips"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"It's simple to determine whether an operation is lazy evaluation or eager evaluation: just look at its return value. If the return value is Stream, then it's lazy evaluation; if the return value is another value or empty, then it's eager evaluation."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"After extracting lambda logic into a method, you can test that method and cover all edge cases"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Use the peek method to observe intermediate values in lambda"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'Set<String> nationalities = album.getMusicians()\n    .filter(artist-> artist.getName().startsWith("The"))\n    .map(artist-> artist.getNationality())\n    .peek(nation-> System.out.println("Found nationality: "+nation))\n    .collect(Collectors.<String>toSet());\n'})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},3546:(e,n,a)=>{a.d(n,{R:()=>s,x:()=>c});var t=a(9729);const r={},i=t.createContext(r);function s(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);