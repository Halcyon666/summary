"use strict";(self.webpackChunksummary=self.webpackChunksummary||[]).push([["2074"],{53910(e,n,t){t.r(n),t.d(n,{metadata:()=>i,default:()=>u,frontMatter:()=>r,contentTitle:()=>l,toc:()=>d,assets:()=>c});var i=JSON.parse('{"id":"background/Java/Concurrent-JVM/lock","title":"Lock","description":"![](https://s2.loli.net/2023/07/15/T2tYREiaSpo3eyx.png) Locks are user-facing, defining the interface for users to interact with locks (e.g. allowing two threads to access in parallel), hiding implementation details;","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/background/Java/Concurrent-JVM/lock.mdx","sourceDirName":"background/Java/Concurrent-JVM","slug":"/background/Java/Concurrent-JVM/lock","permalink":"/en/background/Java/Concurrent-JVM/lock","draft":false,"unlisted":false,"editUrl":"https://github.com/Halcyon666/summary/edit/main/docs/background/Java/Concurrent-JVM/lock.mdx","tags":[{"inline":true,"label":"algorithm","permalink":"/en/tags/algorithm"},{"inline":true,"label":"computer-science","permalink":"/en/tags/computer-science"},{"inline":true,"label":"data-structures","permalink":"/en/tags/data-structures"}],"version":"current","lastUpdatedBy":"halcyon666","lastUpdatedAt":1769299200000,"sidebarPosition":10,"frontMatter":{"id":"lock","title":"Lock","sidebar_label":"Lock","sidebar_position":10,"description":"![](https://s2.loli.net/2023/07/15/T2tYREiaSpo3eyx.png) Locks are user-facing, defining the interface for users to interact with locks (e.g. allowing two threads to access in parallel), hiding implementation details;","tags":["algorithm","computer-science","data-structures"],"last_update":{"date":"2026-01-25","author":"halcyon666"},"sources":["spring-core"]},"sidebar":"tutorialSidebar","previous":{"title":"Final Field Memory Knowledge","permalink":"/en/background/Java/Concurrent-JVM/final-memory-domain"},"next":{"title":"volatile\u57DF\u5185\u5B58\u77E5\u8BC6","permalink":"/en/background/Java/Concurrent-JVM/volatile-memory-domain"}}'),s=t(62615),o=t(77545),a=t(4040);let r={id:"lock",title:"Lock",sidebar_label:"Lock",sidebar_position:10,description:"![](https://s2.loli.net/2023/07/15/T2tYREiaSpo3eyx.png) Locks are user-facing, defining the interface for users to interact with locks (e.g. allowing two threads to access in parallel), hiding implementation details;",tags:["algorithm","computer-science","data-structures"],last_update:{date:"2026-01-25",author:"halcyon666"},sources:["spring-core"]},l,c={},d=[{value:"Lock",id:"lock",level:2},{value:"Concept Difference between Lock and Synchronizer AQS",id:"concept-difference-between-lock-and-synchronizer-aqs",level:2}];function h(e){let n={blockquote:"blockquote",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"lock",children:"Lock"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://s2.loli.net/2023/07/15/T2tYREiaSpo3eyx.png",alt:""})}),"\n",(0,s.jsx)(n.h2,{id:"concept-difference-between-lock-and-synchronizer-aqs",children:"Concept Difference between Lock and Synchronizer AQS"}),"\n",(0,s.jsx)(n.p,{children:"Locks are user-facing, defining the interface for users to interact with locks (e.g., allowing two threads to access in parallel), hiding implementation details;"}),"\n",(0,s.jsx)(n.p,{children:"Synchronizers are for lock implementers, simplifying lock implementation by shielding underlying operations like synchronization state management, thread queuing, waiting, and waking up. Locks and synchronizers isolate the concerns of users and implementers well."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://s2.loli.net/2023/07/15/VABC2cpNlRky3eG.png",alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://s2.loli.net/2023/07/15/XMl6UmZ3GkwvAyO.png",alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://s2.loli.net/2023/07/15/e3fV7UgrLNY46ZP.png",alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://s2.loli.net/2023/07/15/do1wcpmjDu49I3s.png",alt:""})}),"\n",(0,s.jsx)(n.p,{children:'Therefore, the synchronizer provides a CAS-based method to set the tail node: compareAndSetTail(Node expect, Node update). It requires passing the tail node that the current thread "thinks" is correct and the current node. Only after setting successfully does the current node formally establish an association with the previous tail node.'}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://s2.loli.net/2023/07/15/BXPAhpmak3iQdKe.png",alt:""})}),"\n",(0,s.jsx)(n.p,{children:"The synchronization queue follows FIFO. The head node is the node that successfully obtained the synchronization state. When the head node's thread releases the synchronization state, it will wake up the successor node. Upon successfully obtaining the synchronization state, the successor node will set itself as the head node, as shown in the figure below."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://s2.loli.net/2023/07/15/cIp73PN1Ym8Cf2o.png",alt:""})}),"\n",(0,s.jsx)(n.p,{children:"Setting the head node is done by the thread that successfully obtained the synchronization state. Since only one thread can successfully obtain the synchronization state, the method for setting the head node does not need to use CAS to guarantee execution. It only needs to set the head node to the successor node of the original head node and disconnect the next reference of the original head node."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://s2.loli.net/2023/07/15/kSXlBVHZn1AW6zi.png",alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Reference Materials"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:'Book Name: "The Art of Java Concurrency Programming" Authors: Fang Tengfei, Wei Peng, Cheng Xiaoming'}),"\n"]}),"\n"]}),"\n","\n",(0,s.jsx)(a.A,{})]})}function u(e={}){let{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}}}]);